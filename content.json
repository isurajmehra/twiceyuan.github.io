{"pages":[{"title":"404","text":"404the sigularity is here ;-)","link":"/404.html"},{"title":"","text":"QR9pPIzrOj","link":"/baidu_verify_QR9pPIzrOj.html"},{"title":"","text":"google-site-verification: googled02bd30ab6e651fc.html","link":"/googled02bd30ab6e651fc.html"},{"title":"Links","text":"Useful Links JakeWharton drakeet LiteSuits IPN Rio@IPN Friends VoidKing Yuluo Cjhang RedGo Idtk","link":"/links/index.html"},{"title":"关于我","text":".entry { padding: 10px; } .title { font-size: 30px; } #profile-avatar { margin-left: auto; margin-right: auto; -webkit-border-radius: 81px; border-bottom: 1px solid #ccc; border-right: 1px solid #ccc; box-shadow: 0 -2px 4px #FFF; max-width: inherit; width: 160px; height: 160px; } #avatar-content { height: 160px; width: 160px; margin-left: auto; margin-right: auto; } #profile { float: left; width: 100%; line-height: 25px; margin-left: auto; margin-right: auto; margin-top: 25px; margin-bottom: 25px; font-weight: 200; text-align: center; font-size: 18px; } #profile p { font-size: 14px; } .clear { float: none; clear: both; } .note>*:first-child, .markdown_body>*:first-child, .page>*:first-child { margin-top: 0 !important; } .social_label:link, .social_label:visited { background-color: #f9f9f9; padding: 5px 15px 5px 6px; font-size: 14px; line-height: 100%; text-decoration: none; display: inline-block; margin: 0px 10px 10px 0px; border-radius: 20px; outline: none; } div.entry a:link, div.entry a:visited, div.entry a:active { color: #778087; text-decoration: none; word-break: break-all; } #Wrapper { text-align: center; background-color: #e2e2e2; background-image: url(\"https://v2ex.com/static/img/shadow_light.png\"); background-repeat: repeat-x; } .sns-link { color:#4981ce; font-weight:700; margin-left: 4px; margin-right: 4px; } twiceYuan Android Developer 兴趣点包括但不仅限于 Google / Mac / Kotlin / Docker / Chrome OS / NAS 最近在看 Kotlin in Action / One Piece / Rick and Morty 知乎 V2EX GitHub","link":"/about/index.html"},{"title":"","text":"邮箱登录 .bizmail_loginpanel { font-size:12px; width:300px; height:auto; border:1px solid #cccccc; background:#ffffff; margin-left: auto; margin-right: auto; } .bizmail_LoginBox { padding:10px 15px; } .bizmail_loginpanel h3 { padding-bottom:5px; margin:0 0 5px 0; border-bottom:1px solid #cccccc; font-size:14px; } .bizmail_loginpanel form { margin:0; padding:0; } .bizmail_loginpanel input.text { font-size:12px; width:100px; height:20px; margin:0 2px; border:1px solid #C3C3C3; border-color:#7C7C7C #C3C3C3 #C3C3C3 #9A9A9A; } .bizmail_loginpanel .bizmail_column { height:28px; } .bizmail_loginpanel .bizmail_column label { display:block; float:left; width:30px; height:24px; line-height:24px; font-size:12px; } .bizmail_loginpanel .bizmail_column .bizmail_inputArea { float:left; width:240px; } .bizmail_loginpanel .bizmail_column span { font-size:12px; word-wrap:break-word; margin-left: 2px; line-height:200%; } .bizmail_loginpanel .bizmail_SubmitArea { margin-left:30px; clear:both; } .bizmail_loginpanel .bizmail_SubmitArea a { font-size:12px; margin-left:5px; } .bizmail_loginpanel select { width:110px; height:20px; margin:0 2px; } writeLoginPanel({domainlist:\"twiceyuan.com\", mode:\"vertical\"});","link":"/mail/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Activity 接收通知中的发送的 Intent 中的 Extras","text":"在通知中创建一个通知，并且指定通知点击后的 Intent 时，会遇到 put 进 intent 中的 extras 在启动的 Activity 中无法获取到的问题。 查了一下，原因是从通知进入 Activity 时， getIntent() 方法默认返回的是 Activity 的「第一个」Intent，如果从通知点击时，Activity 在后台或者在睡眠，这个 intent 就不是我们想要传入的 intent。 那么怎么获取到新的 intent 呢？当然有办法：重写 Activity onNewIntent(Intent newIntent) 方法，获取这个方法里的 intent 中的 extras，就是我们从通知中 setContentIntent 中 PaddingIntent 里的 Intent 了(通知中发送 Intent 需要有一个 PaddingIntent 包装)。 然后该 Intent（被包装的） 还需要设置 Flag 为： Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP","link":"/2015/11/21/Activity接收Receiver的发送的Intent中的Extras/"},{"title":"Android Studio 升级 El Capitan 之后的两个问题","text":"升级 OS X 11 （El Capitan）后 Android Studio 遇到了两个麻烦的问题，在这里记一下。 1. 升级之后字体发虚这个主要是低分屏下看起来很不舒服，同事的高分屏就没有这个。字体发虚是 JDK 的问题，因为 Jetbrains 全家桶都是基于 Java 开发的，所以把 JDK 的这一不良特性也带了进来，下载直接去苹果官网即可：https://support.apple.com/kb/DL1572 不过也不急解决这个问题，因为下面这个问题可以一起解决 2. 外接显示器+全屏模式会导致一定几率崩溃这个问题是最让人蛋疼的。因为自己平时习惯两个显示器低头看文档抬头写代码，升级之后莫名其妙就会有一定几率崩溃，而且是随机的完全摸不清头脑，在 V2EX 上连发两个问题也没能得到满意的解决方案（不过第一个问题是很快就有人告诉我是 JDK 的问题，还是十分感谢 V2EX 的）。直到今天 IDEA 15 发布了正式版，下载之后发现切换屏幕焦点之后不像我电脑上装的其他 Jetbrains 产品那样闪屏，仔细看了一下它安装包自带了一个 JDK。所以就尝试了把这个 JDK 放到了 Android Studio 下，果然不出所料，Android Studio 也不闪屏了，而且多显示器全屏的问题似乎也解决了。IDEA 15 下载地址：https://www.jetbrains.com/idea/download/ 社区版就可以了，然后从 .app 文件下把 jre 这个文件夹复制到 Android Studio 的对应目录即可。 更令人高兴的是，用 Intellij 提供的 JDK 同样也可以解决第一个问题。","link":"/2015/11/03/Android-Studio-On-El-Capitan/"},{"title":"Android Studio 配置记录","text":"记录 Android Studio 一些自认为有用的配置。 方法分割线 一个类中方法多着看着不习惯，特别是在方法中嵌套监听器之类的时候，总是感觉分不清哪个是外层的哪个是内层的。其实 Android Studio 可以设置方法的分割线。 设置方法： Settings &gt; Editor &gt; General &gt; Appearance 中，勾选「Show method separators」 选中词高亮 默认的选中词效果是一个下划线，如果想在一个类文件中寻找这个下划线估计不太容易。可以通过修改这个词的背景色来增加它的可辨识性。修改方法如下： Settings &gt; Editor &gt; Colors &amp; Fonts &gt; General 中，改变 Identifier under caret 和 Identifier under caret(write) 的 background 属性就可以了。 成员变量按列对齐 强迫症患者福音，自动格式化的时候对齐类中成员的关键字、类型和变量名，Android 中使用 Butterknife 生成 View 绑定代码时强烈使用，有效改善生成代码的可读性。 Settings &gt; Code Style &gt; Java &gt; Wrapping and Baces &gt; Group declarations &gt; Align fileds in columns（勾上） Tips of the day 这个都知道，是默认开启的，但是如果不小心关掉了呢？选择菜单栏上的 Help &gt; Tips of the day 就可以重新开启了。 Live template 编写代码模板。这个在 Settings 里搜索就可以找到，可以编辑一些常用的代码片段使用自己设定的几个字母快速生成。当然，某些情况下更方便和优雅的还是抽象出方法。","link":"/2015/05/09/Android-Studio-配置记录/"},{"title":"Android SDK 国内的镜像站","text":"国内更新Android SDK不通畅，可以尝试使用设置镜像地址。 大连东软的 Android SDK 镜像地址：mirrors.neusoft.edu.cn:80 UPDATE：最近国内有服务器了，是北京的，所以不需要镜像了大家可以使用 ping.chinaz.com 来看一下哪个 IP 访问最快来修改自己的 hosts。不过大部分地区应该可以直接访问了。","link":"/2015/02/16/AndroidSDKMirror/"},{"title":"Android 上的 git 服务器应用：Gidder","text":"好久没更新文章了，水一篇娱乐向的应用推荐：Gidder —— 在 Android 上搭建 git 服务器。 之前项目组一直使用 github 啦 Coding 啦之类的公共 git 服务（以后估计也是），github 不用说了，功能强大历史悠久但是速度慢，coding 是国内深圳（？）一家公司做的，速度啥的还不错。反正公共 git 服务的好处就不用多说了，省心省事省时省力。 不过为了代码让别人看到有损公司形象的安全。有时也需要自己搭一个 git 服务器，比如 gitlab 就是很好的一个 git 全家桶，包括了和 github 一样的 web 端，真是棒棒哒。但是我们没有服务器，只有一个二手国产低端机，所以好的废话不多说了开始！介！绍！ 下载链接https://play.google.com/store/apps/details?id=net.antoniy.gidder.beta&amp;hl=en 使用说明安装之后打开就会发现，这货压根不需要什么使用说明啊！简单到爆！不过相应的，不能在客户端建立仓库和用户，只能在这个 app 中建立固定的，不过这也够用了。 坑欣喜若狂的边抖腿边把项目导入 Android Studio 中后，发现 push 有问题，push 时提示： Push failed: Failed with error: fatal: Could not read from remote repository. google 了一下，发现是用了 Native 的 git，密码没办法填写（gidder 只能设置密码登录而不能使用私钥（Servers Ultimate 可以）），解决方法就是把 git 的设置从 Native 改为 Built-in 就行了，这样在 git push 时就会要求输入密码，然后输入在 gidder 中设置的对应账户密码就可以推送成功了。 感想把 git 服务器握在手中有种莫名的安全感 (:з」∠)。 好久没写东西发现都不能好好说话了，写完了去吃药了 bye(╯-╰)/ 。 相关链接 Gidder 居然是开源的！ https://github.com/antoniy/Gidder 一个类似 Gidder 的更黑科技的服务器全家桶 Servers Ultimate Pro，支持各种常用服务器，地址请自行搜索。","link":"/2015/09/03/Android-上的-git-服务器应用：Gidder/"},{"title":"AndroidStudio中so文件存放路径问题","text":"最近要做一个关于地图导航的模块，用到了百度地图的 API，在 Hello World 的时候就出问题了： 文档中要求 so 文件放在 libs/armeabi/ 下，这样做之后编译通过，运行时报错： 1java.lang.UnsatisfiedLinkError: Couldn&apos;t load BaiduMapSDK_v3_0_0 from loader dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.twiceyuan.baidumaptest-1.apk&quot;],nativeLibraryDirectories=[/data/app-lib/com.twiceyuan.baidumaptest-1, /vendor/lib, /system/lib]]]: findLibrary returned null 查了一下，原来是 so 文件存放路径问题，Android Studio 下 so 文件的存放路径为：src/main/jniLibs/armeabi/ 之后运行成功了。","link":"/2014/08/04/AndroidStudio中so文件存放路径问题/"},{"title":"Android appcompat-v7 兼容包导致 MENU 按键不能监听到的解决方案","text":"在使用 com.android.support:appcompat-v7 版本 21 以上，并且 Activity 继承 ActionBarActivity 或者 AppCompactActivity 时，会发现 onKeyDown() 方法和 onKeyUp() 方法均获取不到菜单键 (MENU) 的点击事件。 经过搜索，应该是 v7兼容包的问题，解决方案如下： 创建类 AppCompatActivityMenuKeyInterceptor，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import android.support.v7.app.AppCompatActivity;import android.support.v7.internal.view.WindowCallbackWrapper;import android.view.KeyEvent;import android.view.Window;import java.lang.ref.WeakReference;import java.lang.reflect.Field;public class AppCompatActivityMenuKeyInterceptor { private static final String FIELD_NAME_DELEGATE = “mDelegate”; private static final String FIELD_NAME_WINDOW = “mWindow”; public static void intercept(AppCompatActivity appCompatActivity) { new AppCompatActivityMenuKeyInterceptor(appCompatActivity); } private AppCompatActivityMenuKeyInterceptor(AppCompatActivity activity) { try { Field mDelegateField = AppCompatActivity.class.getDeclaredField(FIELD_NAME_DELEGATE); mDelegateField.setAccessible(true); Object mDelegate = mDelegateField.get(activity); Field mWindowField = mDelegate.getClass().getSuperclass().getSuperclass().getDeclaredField(FIELD_NAME_WINDOW); mWindowField.setAccessible(true); Window mWindow = (Window) mWindowField.get(mDelegate); Window.Callback mOriginalWindowCallback = mWindow.getCallback(); mWindow.setCallback(new AppCompatWindowCallbackCustom(mOriginalWindowCallback, activity)); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } private class AppCompatWindowCallbackCustom extends WindowCallbackWrapper { private WeakReference&lt;AppCompatActivity&gt; mActivityWeak; public AppCompatWindowCallbackCustom(Window.Callback wrapped, AppCompatActivity appCompatActivity) { super(wrapped); mActivityWeak = new WeakReference&lt;AppCompatActivity&gt;(appCompatActivity); } @Override public boolean dispatchKeyEvent(KeyEvent event) { final int keyCode = event.getKeyCode(); final int action = event.getAction(); AppCompatActivity appCompatActivity = mActivityWeak.get(); if (appCompatActivity != null) { if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; action == KeyEvent.ACTION_DOWN) { if (mActivityWeak.get().onKeyDown(event.getKeyCode(), event)) return true; } else if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; action == KeyEvent.ACTION_UP) { if (mActivityWeak.get().onKeyUp(event.getKeyCode(), event)) return true; } } return super.dispatchKeyEvent(event); } }} 并且在需要监听菜单键的 Activity 的 onCreate 方法中调用，调用方法为： AppCompatActivityMenuKeyInterceptor.intercept(this); 参考来源： Issue 159795: KEYCODE_MENU is broken on appcompat 22.0.0 Upgraded to AppCompat v22.1.0 and now onKeyDown and onKeyUp are not triggered when menu key is pressed","link":"/2015/05/07/Android-appcompat-v7-兼容包导致-MENU-按键不能监听到的解决方案/"},{"title":"Android应用证书签名","text":"在 Android Studio 上给应用签名很简单，首先在菜单中选择 Generate Signed APK，然后会有一个向导，如果之前有证书则需要填写证书路径和密码，如果没有的话可以根据向导创建一个，然后一直 next 直到 finish 就好了。 不过说下遇到的一些小问题： 之前用 debug 证书签名的应用，如果需要安装 release 版本的应用，有时候在卸载本地应用后仍然安装不上新的应用，这时可以使用 adb uninstall PACKAGE_NAME 完整卸载掉应用。 在应用存在是 adb install 可能会安装不上版本升级后的应用。这时需要使用 adb install -r 命令即可。","link":"/2015/05/11/Android应用证书签名/"},{"title":"Android网络调试开启方法","text":"最近卖了nexus 4换了nexus7(2013)玩，发现之前一直在CM上使用的网络调试在原生Android 5.0上并没有开启的选项，Google了一下，貌似原生的Android都没有。 不过Android本身还是提供这个功能，开启有两种方法： 连接USB数据线 打开usb调试，Terminal输入, adb tcpip 5555（端口号） adb connect 192.168.1.199 （Android设备IP地址) adb usb 使用回usb调试 无需数据线 且可解决部分机器在方法1时出现的“unable to connect to 192.168.1.199:5555”错误 在android设备上安装 “终端模拟器”等类似shell命令工具，使用下面命令（需root权限）： TCP/IP方式： setprop service.adb.tcp.port 5555 stop adbd start adbd usb方式： setprop service.adb.tcp.port -1 stop adbd start adbd 参考：stackoverflow","link":"/2014/11/21/Android网络调试开启方法/"},{"title":"ArrayList 是线程不安全的","text":"发现自己在代码中经常会犯一个常识性错误：在多线程环境下使用同一个 ArrayList。ArrayList 是线程不安全的，不安全性主要表现在元素的操作互相没有互斥性，例如在线程1中添加了元素 a，而在线程2 中查询该 list 的长度时，却可能发现 list 长度为 1，而元素只有一个 null。 talk is cheap: 123456789101112131415161718private static void test(List&lt;String&gt; stringList) { // 用于获得 List 的实现类名，例如 ArrayList String className = stringList.getClass().getSimpleName(); new Thread(() -&gt; Stream.of(\"1\", \"2\").forEach((e) -&gt; { stringList.add(e); System.out.println(className + \" 添加了 \" + e); System.out.println(className + stringList.toString()); System.out.println(className + \" [length=\" + stringList.size() + \"]\"); })).start(); new Thread(() -&gt; Stream.of(\"1\", \"2\").forEach((e) -&gt; { stringList.add(e); System.out.println(className + \" 添加了 \" + e); System.out.println(className + stringList.toString()); System.out.println(className + \" [length=\" + stringList.size() + \"]\"); })).start();} 上述代码是一个方法，用于传入一个 List，然后建立两个线程，同时添加”1”, “2”，两个元素。并且在每次添加之后打印添加的结果。 建立一个 ArrayList 对象，并调用上述方法测试。 12List&lt;String&gt; stringList1 = new ArrayList&lt;&gt;();test(stringList1); 代码执行后，输出可能就是这样的（多线程代表了诸多不确定性，每次输出结果都可能不同）： 123456789101112ArrayList 添加了 1ArrayList 添加了 1ArrayList[null, 1]ArrayList[null, 1]ArrayList [length=2]ArrayList 添加了 2ArrayList [length=2]ArrayList 添加了 2ArrayList[null, 1, 2]ArrayList [length=4]ArrayList[null, 1, 2, 2]ArrayList [length=4] 如何改进？在上述例子中，可以体现出在 add，size 和 toString 的执行过程中出现了一个方法执行到一半而执行了另一个方法的情况，由此产生了输出不一致的问题。针对上述情况，继承 ArrayList 进行同步限制： 12345678910111213141516171819202122232425private static class SafeArrayList&lt;T&gt; extends ArrayList&lt;T&gt; { private static final Object lock = new Object(); @Override public boolean add(T o) { synchronized (lock) { return super.add(o); } } @Override public String toString() { synchronized (lock) { return super.toString(); } } @Override public int size() { synchronized (lock) { return super.size(); } }} 这样执行之后的输出： 123456789101112SafeArrayList 添加了 1SafeArrayList[1]SafeArrayList 添加了 1SafeArrayList[1, 1]SafeArrayList [length=2]SafeArrayList [length=2]SafeArrayList 添加了 2SafeArrayList 添加了 2SafeArrayList[1, 1, 2, 2]SafeArrayList[1, 1, 2, 2]SafeArrayList [length=4]SafeArrayList [length=4] VectorJava 中的 Vector 就是针对于多线程情况下做过处理的一个 List 实现。在上述代码实现中，只实现了三个方法的互斥，实际使用上需要考虑的则远不止这么多，因此需要真正做到线程安全的操作 List 建议使用 Vector。 ReentrantReadWriteLock 和 CopyOnWriteArrayList评论中成哥给了另外两种更好的方案。避免评论丢失也搬到这边来： Vector 和使用 synchronize 都是非常强的独占锁，读写的效率并不高。其实有以下两个方法进行补充吧： 使用 ReentrantReadWriteLock 读写锁，解除了读与读之间的互斥锁。 使用 CopyOnWriteArrayList，以牺牲空间的代价来获取锁的消耗，即读的时候没有锁，写的时候，采用复制到新的内部数组来实现。","link":"/2016/06/09/ArrayList-is-not-thread-safe/"},{"title":"Android 绑定 View 终极利器——ButterKnife","text":"Android 中估计最简单枯燥而且无意义的事情就是 findViewById 了，在我们真切期望 Google 爸爸亲自优化这一过程的同时，不少同学也亲自实践做出了一些好用的工具，在我用过的这些工具中，最强大的无疑就是 ButterKnife 了。 ButterKnife 是 do one thing, and do it well 的典型，它的使用和大多数同类工具相同，通过注解、注入两步完成。然而程序员的懒是无止境的，所以有了这个： 使用 ButterKnife 步骤： gradle 配置文件 dependencies 添加 compile &apos;com.jakewharton:butterknife:6.1.0&apos; Android Studio 插件安装，搜索 Android Butter Zelezny，安装，重启。 在 onCreate 方法的 setContentView 的 R.layout.xxx 上，Ctrl/Command + N，选择最下方 Generate Butterknife Injections，勾选（默认全选）需要绑定的 View，填写变量名（默认和 id 相同），选择是否创建 ViewHolder（默认否），confirm，一切就都做好了。 #end","link":"/2015/06/02/ButterKnife/"},{"title":"为开源软件选择协议","text":"转载自阮一峰的博客：http://www.ruanyifeng.com","link":"/2015/09/26/Choose-Licenses/"},{"title":"Chrome 下载新浪乐库在线试听音乐","text":"比如新浪乐库，在播放器上（其实哪边都行）右击选择 Inspect Element，在 Developer Tools 选择 Resources，随便找一下MP3的资源下载，基本就是现在试听的了，比如新浪乐库的是在 Frames -&gt; (ningsibuqu) -&gt; media 里，有个getmp3，点击直接就下载了。 另，喜欢请支持正版。:-)","link":"/2014/10/28/Chrome_download_online_music/"},{"title":"连接 Docker Container 的几种方式","text":"经过熟悉之后，在 docker 里安装了一个 ubuntu 准备学习使用。然后遇到了一些问题： 使用 docker run -d ubuntu 之后，container在运行之后马上退出了。 原因很简单，在docker run 之后没有命令参数，添加 bash 就可以了： docker run -d ubuntu /bin/bash 运行是运行了，在 docker pa -a 中也可以看到 container 跑的正欢快，问题来了：怎么和它交流？发现官方版 ubuntu 是不像之前装的 oracle 一样自动开启 ssh 的（经过观察这部分是写在之前 Dockerfile 里的），但是想要进入 container 自己还只会使用 ssh。所以我尝试了 docker attach [container id]。成功了，但是也有缺点，在我退出 shell 的时候，该 container 也被关闭了。这肯定不是官方优雅的姿势。 使用 nsenter 进入 container经过 google 发现了这篇文章。里面介绍最推荐的是使用 nsenter，这里照抄下安装方式： 这个程序的安装方式很独特，使用docker进行安装： 1$ docker run --rm -v /usr/local/bin:/target jpetazzo/nsenter 使用方法也很简单，首先你要进入的container的PID： 1$ PID=$(docker inspect --format {{.State.Pid}} &lt;container_name_or_ID&gt;) 然后就可以用这个命令进入container了： 1$ nsenter --target $PID --mount --uts --ipc --net --pid 为了使用方便可以写一个脚本自动完成： 123$ cat /bin/docker_enter#!/bin/bashsudo nsenter --target `docker inspect --format {% raw %}{{.State.Pid}}{% endraw %} $1` --mount --uts --ipc --net --pid bash 这样每次要进入某个 container 只需要执行docker_enter &lt;container_name_or_ID&gt;就可以了。 使用 boot2docker需要注意的在安装之后，发现重启 docker 之后命令就失效了。在 nsenter 官方 github 中找到解答： If you are using boot2docker, you can use the function below, to: install nsenter and docker-enter into boot2docker’s /var/lib/boot2docker/ directory, so they survive restarts. execute docker-enter inside of boot2docker combined with ssh12345&gt; docker-enter() {&gt; boot2docker ssh '[ -f /var/lib/boot2docker/nsenter ] || docker run --rm -v /var/lib/boot2docker/:/target jpetazzo/nsenter'&gt; boot2docker ssh -t sudo /var/lib/boot2docker/docker-enter \"$@\"&gt; }&gt; You can use it directly from your host (OS X/Windows), no need to ssh into boot2docker. 我并不希望使用 ssh 来连接 docker 所以只需要将前面安装命令中的路径修改为 /var/lib/boot2docker/就可以了","link":"/2015/03/21/Connect-to-Docker-Container/"},{"title":"HelloSwift","text":"Swift作为一个明星语言从诞生就颇受关注。这几天看了一些视频教程，发现基本语法从刚出炉到现在就有很多变动，看来看视频学语言还是件不太靠谱的事情，在这里总结一下Swift的基本语法，以供之后自己和别人查阅。当然最好的还是读文档，中文翻译很nice：Swift中文文档。本文讲的是最最基本的语法，适合有过其他语言基础的人来快速熟悉Swift。 Hello, World编程第一步。当你创建出来一个Swift程序时其实开发环境已经生成了这一行代码： println(&quot;Hello, World!&quot;) 变量和常量变量是var，常量是let 比如： var a = 1 // 变量a var b = 2 // 变量b let c = a + b // 常量c 数据类型变量和常量定义中也可以看出，Swift可以和JS一样定义时不指定类型。想要指定的话，在变量名后加冒号和数据类型名就可以了，比如： var str:String = &quot;我是一个字符串&quot; var i:Int = 1 // 这是一个无法自证的整型 字符串操作字符串操作方面Swift有些特殊，但也十分方便。两个字符串之间可以直接使用+号来连接，非字符串可以使用”(var)”来进行转换并与其他字符串连接，类似于Java的toString()方法。比如： 1234567var msg = &quot;Hello, I&apos;m&quot; // 字符串var age = 22 // 整型let result = msg + &quot; \\(22)&quot; // 转换整型并与字符串连接// Output// Hello, I&apos;m 22 数组数组定义上，貌似和刚发布时有些不同，比如var arr = String[]()这种方法已经失效。想要定义一个空数组的方式为： 123456// 不指定类型的var arr = []// 指定数组元素类型的var arr2:[String] = []// 指定元素的var arr3 = [&quot;Hello&quot;, 123, 255.5] 字典类似于Map的数据类型。可以在定义时直接赋予初值。有这样一些基本用法 12345678910var dict = [&quot;name&quot;: &quot;twiceYuan&quot;, &quot;site&quot;: &quot;twiceyuan.com&quot;] // 赋初值dict[&quot;age&quot;] = &quot;22&quot; // 添加或修改键值dict[&quot;birth&quot;] = &quot;19930302&quot; // 添加或修改键值dict.removeValueForKey(&quot;site&quot;) // 根据键删除值println(dict) // 输出// Output// [age: 22, birth: 19930302, name: twiceYuan] 循环这边遇到的不同最多。这边只说现在的格式吧： for循环 遍历数组 12345678var arr = [&quot;Hello&quot;, &quot;World&quot;]for str in arr { println(str)}// Output// Hello// World 带计时器的遍历 1234567var arr = [&quot;Hello&quot;, &quot;World&quot;]for index in 0...1 { println(&quot;\\(i+1). &quot;arr[index])} // Output// 1. Hello// 2. World 字典的遍历 12345678let dict = [&quot;name&quot;: &quot;yuan&quot;, &quot;site&quot;: &quot;twiceyuan.com&quot;]for (key, value) in dict { println(&quot;\\(key)是 \\(value)&quot;)}// Output// name是yuan// site是twiceyuan.com 还有一种类似C语言的遍历，功能和也可实现上述循环的功能 （TO BE CONTINUE）","link":"/2015/01/24/HelloSwift/"},{"title":"Hexo升级3.0啦","text":"Hexo 最近也升级 3.0 了。3.0 所有插件貌似都进行了模块化，在配置时附带了一些最基本的，其他的需要用户单独安装，比如 git 部署工具、RSS 生成工具。 详细的还是参考官方文档吧，现在中文也支持的很好。 另外，之前的添加的 hexo new 之后打开文件的脚本也失效，新的脚本为： 12345var spawn = require(&apos;child_process&apos;).spawn;// Hexo 3hexo.on(&apos;new&apos;, function(data){ spawn(&apos;open&apos;, [data.path]);}); 另外，Hexo3 也支持了一个非常实用的功能，以前也见到过很多人建议过，个人也觉得是对于管理博客非常需要的：资源文件管理。下面这个图片就是使用这个来显示的。","link":"/2015/03/15/Hexo升级3-0/"},{"title":"How to speed up gradle build time","text":"If you use the new Gradle build system with Android (or Android Studio) you might have realized, that even the simplest Gradle call (e.g. gradle project or grade tasks) is pretty slow. On my computer it took around eight seconds for that kind of Gradle calls. You can decrease this startup time of Gradle (on my computer down to two seconds), if you tell Gradle to use a daemon to build. Just create a file named gradle.properties in the following directory: /home//.gradle/ (Linux) /Users//.gradle/ (Mac) C:\\Users\\.gradle (Windows) Add this line to the file: org&lt;span class=&quot;class&quot;&gt;.gradle&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.daemon&lt;/span&gt;=true `&lt;/pre&gt; From now on Gradle will use a daemon to build, whether you are using Gradle from command line or building in Android Studio. You could also place the gradle.properties file to the root directory of your project and commit it to your SCM system. But you would have to do this, for every project (if you want to use the daemon in every project). Note: If you don’t build anything with Gradle for some time (currently 3 hours), it will stop the daemon, so that you will experience a long start-up time at the next build. Note：Performance improvements are one of the great tasks in the Gradle roadmap for 2014 (and reaching into 2015). So I hope, we’ll see the general performance increasing within these years. Note: This does only affect console builds. Android Studio always uses a Gradle daemon (and depending on your settings some other optimizations). &gt; 来源：[https://www.timroes.de/2013/09/12/speed-up-gradle/](https://www.timroes.de/2013/09/12/speed-up-gradle/) （_至今没过英语四级的人的蹩脚翻译仅供参考_） 如果你使用新的 Gradle 构建系统（或 Android Studio）你也许认识到简单的 Gradle 调用（例如 gradle project 或者 gradle tasks）是如此之慢。在我的电脑上那些gradle 调用要花 8 秒左右。如果你告诉 Gradle 使用一个后台驻留进程去构建就可以减少 Gradle 的启动时间。只需要创建一个名为`gradle.properties`在下面的文件夹中： /home//.gradle/ (Linux) /Users//.gradle/ (Mac) C:\\Users\\.gradle (Windows) 在该文件中添加这样一行： `org.gradle.daemon=true 现在无论你使用 Gradle 命令行还是在 Android Studio 中， Gradle 将使用一个驻留进程去构建项目。你可以把gradle.properties文件放在你项目的根目录并提交到你的 SCM 系统。但是你必须每个项目都这样做（如果你想每个项目都使用后台驻留进程）。 Note：如果你在一段时间（当前是3小时）内不使用 Gradle 构建任何东西，它将会终止这个进程，那么你会在下一次构建时花费很长时间。 Note：不会翻译。 Note：这个只会影响控制台的构建。Android Studio 总是会使用一个 gradle 后台驻留进程（并且依靠于你设置上的其他优化）","link":"/2015/04/15/How-to-speed-up-gradle-build-time/"},{"title":"红米2一周体验与吐槽","text":"前段时间华为c8817l因试图修改内置存储分区搞成了黑砖，无计可施也一直想换新机就买了现货的红米2电信4G版。 虚伪的高度评价总的来说，MIUI还是一个能够自洽的系统，在它自己的生态圈里且遵守一个大陆良民的使用规范下还算体验不错：类似iMessage的网络短信，自己的应用商店主题和桌面，以及为用户可能安装的极小一部分的应用预设的美化后的图标。 实际内心中的吐槽可能说了这些，MIUI的缺点也浮出水面了——和其他系统关系极其恶劣。首先撇去界面部分不说，单是一个联系人，愣是搞了一两天也没能完美的迁移过来。除此之外，其内置的安全助手及其相关的调度机制也使得很多应用无法在后台工作，第三方通讯录同步工具工作不稳定，代理工具不能常驻后台，总而言之，MIUI在我心目中的感觉就是一个有iOS般封闭的野心但还没有相应完善生态圈能力的一个OS。 首先是界面图标的坑。主题内置的图标极少，适配不到主题美化图标的app怎么办？如果能像原生系统一样直接原封不动的显示出来也好，虽然可能破坏主题整体的一致性，但是这个至少现在是个没办法简单粗暴就能解决的事情。而MIUI就简单粗暴的给图标加个统一配色的背景，虽然乍一看整体一致性有了，但后加上背景的图标每个几乎都是丑的惨不忍睹。在Android整个生态圈的app普遍没有一直风格图标的大环境下，要么放弃这种在形状上的统一，要么提供一种便捷的方式给用户更新没有适配的图标才是解决问题的方法。 其次是联系人，这里的问题主要是联系人群组的问题。虽然对这个标准不是很了解，至少之前在各种国产机、Nexus设备、iOS还是OS X设备上都没出过乱子，到了MIUI上，联系人分组是怎么都同步过来：先是联系人和群组分离同步到不同账户，又是群组显示成了联系人。这些只说明一个事实，MIUI在联系人的标准上动了手脚，试图做出个自己的标准。但是一个如此基本的功能上，做出一个和普通标准不兼容但功能上一样的标准的意义何在？实在搞不懂MIUI的用心。 实际内心中的中度评价吐槽结束之后说说除了软件之外的部分，红米的定位和价格都是摆在那的，但是实际拿到真机之后还是感觉相当不错，不管是屏幕后盖分辨率还是包装，都让人感觉不出多少廉价感。 其实冷静下来，多平台的通讯录同步其实也不是一个使用率很大的功能，对于没有这方面需求的人，比如小米手机为主力设备的同学来说，联系人也不是个问题；对于美观要求没那么高的，图标也不是个问题；对于不使用国外应用的良民来说，国产app在上面也可以跑得很欢。 凑合着用吧希望能在以后用到更加完善的MIUI，在此之前，我估计也只能放弃联系人分组这一功能，或者看看有没有适配良好的CyanogenMod先用着了。如果有时间和精力，也想自己做个兼容MIUI联系人格式的iCloud同步工具，不过没有（……）。","link":"/2015/02/26/HongMi2Exp/"},{"title":"在 Parallels Desktop 10 上 安装的 Fedora 上安装 Oracle 11gR2","text":"在 Fedora 上安装 Parallels Tools 有些小问题。需要在此之前安装一些依赖： 参考来源 权威指南： http://oracle-base.com/articles/11g/oracle-db-11gr2-installation-on-fedora-21.php从中午到晚上总算折腾好了，不得不说坑还是挺多的，建议直接按照上面链接来一步一步做。其他版本理论上也都可以，主要是安装好依赖、环境变量和用户路径权限。我使用的是Fedora 21 LXDE版本的桌面环境。另外看到网上也有在 Docker 里安装好的，也未尝不是一个好的选择。","link":"/2015/03/19/Install-Oracle-on-Fedora/"},{"title":"LoaderManager 简介","text":"占坑。","link":"/2015/04/16/LoaderManager-简介/"},{"title":"macOS 文件系统的大小写敏感转换","text":"本文介绍如何通过命令转换一个大小写敏感的 macOS 文件系统到非敏感。 感谢 https://github.com/cr/MacCaseSensitiveConversion 提供的宝贵经验，本文主要复述原作者提供的方法。 前不久因为硬盘事故重装了系统，无意重装时无意选择了 Case Sensitive(大小写敏感) 的 APFS 进行格式化。直到昨天安装 Steam 时发现安装后运行不了，查了一下原来是因为之前选择文件系统大小写敏感的原因，然后搜索到了 GitHub 上前文提到的 repo，了解到还有一系列应用比如 Creative Cloud 不能运行，索性晚上按照其提供的方法转换了文件系统格式。总体步骤如下： 解决现有系统下所有因为大小写造成的命名冲突 生成一个全新的 TimeMachine 备份 修改该备份中的一个关于大小写敏感的变量 从这个备份中进行恢复 解决问题之前的准备尽量关闭磁盘加密，因为加密磁盘会极大的增加以下几个步骤的时间。 1. 解决命名冲突可以借助上述 repo 中提供 casecheck.py 来检查现有系统中大小写不敏感时的文件冲突。这里的冲突是指例如 appstore 和 AppStore 两个目录在同一路径下，在大小写敏感的文件系统时它是合法的，但是在大小写不敏感的文件系统下就是有冲突的。我们要转换成大小写不敏感的文件系统首先要解决的就是这个问题。使用该脚本后会输出很多文件，理论上你要一个个手动处理这些文件。如果文件位于缓存路径下可以直接删掉，位于用户目录下则要自己决定如何避免命名上的冲突。 2. 做一个全新的备份这点没什么好说的，TimeMachine 作为 macOS 自带应用，可以方便的把系统备份到一个硬盘上。建议备份完成后把备份文件再多存一份，这样即使后面的操作失败了，至少你还可以恢复到之前的大小写敏感的文件系统下。 备份之前确保已经完成了第一步的命名冲突。如果你之前已经有了备份而只进行的增量备份，可以把之前备份删除掉，进入到你的硬盘目录下，使用 tmutil 删除之前的备份，只保留最后一个： 查看有多少备份： 12345$ ls -l /Volumes/TimeMachiiine/Backups.backupdb/tin/total 9drwxr-xr-x@ 3 root wheel 204 29 Aug 10:04 2016-08-29-100422/drwxr-xr-x@ 3 root wheel 204 29 Aug 11:05 2016-08-29-110526/lrwxr-xr-x 1 root wheel 17 29 Aug 11:08 Latest -&gt; 2016-08-29-110526 删除之前的备份： 1$ tmutil delete /Volumes/TimeMachiiine/Backups.backupdb/tin/2016-08-29-100422 千万不要使用 rm -rf 来操作备份中的文件，那样会损坏备份文件的结构导致备份无法恢复(我猜的)。 3. 改表备份文件中的一个标志使用以下命令改变备份文件中关于大小写敏感的标志，其中 TimeMachiiine 是你存放备份的硬盘名，MacHD 是你现在系统的硬盘名。 123$ sudo /System/Library/Extensions/TMSafetyNet.kext/Contents/Helpers/bypass \\ xattr -w com.apple.backupd.VolumeIsCaseSensitive 0 \\ /Volumes/TimeMachiiine/Backups.backupdb/tin/Latest/MacHD 4. 恢复系统 重启你的 Mac 按住 Cmd+R 后按开机键，进入恢复模式的系统 选择从 TimeMachine 恢复 选择你之前操作过的那个备份 进行恢复 恢复时会提示你要抹点目标硬盘所以你不需要手动格式化。如果之前操作进行的顺利，恢复完之后就完全解决了该问题。再次感谢文本头部提到的 repo 中提供的宝贵经验和脚本。","link":"/2018/12/11/MacCaseSensitiveConversion/"},{"title":"进不了系统的情况下用 Dp1安装 Mavericks","text":"今天手贱+心急，在10.8下直接安装了dp7的升级包，结果是10.8进不去（无限菊花），10.9装不了；更悲剧的是，想重装 MTLion，系统版本显示为10.9提示已安装更高版本的系统不能覆盖安装。 下载了 Mavericks DP1 接了个 Macbook 好不容易写到 U 盘里了，发现 dp1的镜像文件不是官方发布的那种系统安装镜像，写进 U 盘不能直接引导 最后发现开机进恢复盘之后有终端（在上面的第三个菜单栏里），终端可以浏览文件系统的所有文件，所以试着打开 U 盘中的安装文件，也就是用open /Volumes/OS\\ X\\ Mavericks\\ 10.9\\ DP1/Install\\ OS\\ X\\ 10.9\\ Developer\\ Preview.app/命令，结果终端提示不支持 open 命令。。。。直接进入到「安装 OS X 10.9 Developer 预览版.app」的目录下通过./安装 OS X 10.9 Developer 预览版.app的方式打开，又提示 「is a directory」，不能像系统中那样直接打开，无耐中又试了试进入 app 这个文件夹的 Content\\MacOS\\ 下直接运行二进制文件，这次终于可以了，显示了和系统中一样的安装界面，接下来一切按照常理出牌就好了 ps： 好久没装 dp1了，安装的时候貌似要关掉网络？第一次安装的提示系统没有经过验证之类的，第二次关掉网络就好了。 安装文件加载完毕后提示重启这个时候按重启没有用，手动关掉程序重启就可以了。 其实不用写到 U 盘了，磁盘实用工具可以直接打开硬盘中的镜像文件 总而言之，自己是犯了比较火星的错误。忙乎大半天总算没有丢失任何东西，希望能给像我一样（估计不多。。）装错升级补丁进不了系统的一些帮助 另外，在论坛里有人给出了根据 DP1制作 USB 启动盘的教程，个人认为不是很有必要，因为 U盘安装要比直接在硬盘里用镜像文件安装要慢很多，在这里也给出链接，需要的人可以了解一下。[教程] 制作OS X Mavericks(10.9)安装U盘","link":"/2013/09/08/MavericksDP安装/"},{"title":"OS X 下实用 dd 工具制作 Linux 的启动盘","text":"以 Ubuntu 为例，转换 iso 文件为 dmg 文件 hdiutil convert -format UDRW -o ubuntu-12.10-desktop-amd64.dmg ubuntu-12.10-desktop-amd64.iso 查看 U盘挂载位置 diskutil list卸载 U盘 diskutil umountDisk /dev/disk1 写入(据说 disk1前加 r 是可以加快写入速度) sudo dd if=ubuntu-12.10-desktop-amd64.dmg of=/dev/rdisk1 bs=1m","link":"/2013/09/16/OSX下使用dd工具制作Linux启动盘/"},{"title":"音乐 ID3 乱码修复工具","text":"音乐导入进 iTunes 常会有ID3信息乱码，图形工具大多需要付费，介绍一个免费好用的 Java 编写的命令行工具 id3iconv，官方网站在这儿可自行下载。 使用也非常简单，java -jar id3iconv-0.2.1.jar [需要转换编码的 MP3文件].mp3 就可以了。根据这个还可以直接一个批量转换的脚本，好久没碰 Shell 就不在这里写了。","link":"/2014/10/28/OSX_ID3_Convert/"},{"title":"macOS下为单个应用设置语言","text":"OS X下的联系人应用在系统语言为英文时，排序总是有问题的，切换到中文就正常了。但又不喜欢看中文的界面，经过搜索可以为某个特定应用设置特定的语言。 defaults write com.apple.AddressBook AppleLanguages &apos;(&quot;zh_CN&quot;)&apos; 其中com.apple.AddressBook是应用的包名，可以在Info.plist里查找到。 逆操作： defaults delete com.apple.AddressBook AppleLanguages","link":"/2015/01/11/OS-X下为单个应用设置语言/"},{"title":"在 Docker 上配置 Oracle","text":"上一篇说了自己多么智商捉急以至于一个 oracle 装了一下午。所以趁此机会赶时髦学习一下 Docker 的使用。 ##安装 Docker ###1. Ubuntu 第一次尝试选择的是 Ubuntu，官方源中已经有了 Docker，所以直接使用系统包管理安装就可以了：sudo apt-get install docker.io ###2. OS X 尝试Ubuntu成功后，为了更加减轻宿主机的负担，又尝试了在OS X上安装。官方提供了Boot2Docker 的安装包，直接安装就好了。 Boot2Docker运行原理是在VirtualBox建立一个轻量级的VM（冷启动大概也就四五秒的样子），所以要比虚拟机开个Ubuntu要轻的多。安装之后，可以通过运行 App 里的Boot2Docker 进入 Docker 的Shell，也可以通过 boot2docker ssh 进入。另外在宿主机中连接 Docker 中的 Container 需要使用 Docker 的 IP。这个 IP 在 使用 boot2docker 启动的时候可以看到，或者通过 boot2docker ip 来查看。 ##下载别人装配好的 Dockerfile 更正：这一步和下面一步 docker pull 没有关系。下面的docker pull命令是从docker的类似包管理的官方源服务器上拉取的，而不是本地，所以需要良好的网络环境。如果需要根据本地Dockerfile来创建容器，可以使用docker build命令。 地址：https://github.com/wnameless/docker-oracle-xe-11g 。直接 git clone 到本地就行了 ##安装 docker shell 下： docker pull wnameless/oracle-xe-11g 运行，并开放 49160 和 49161 端口，分别对应 22 端口和 oracle 端口（SSH 和 oracle 数据库） docker run -d -p 49160:22 -p 49161:1521 wnameless/oracle-xe-11g 数据库信息如下： hostname: localhost port: 49161 sid: xe username: system password: oracle SYSTEM和SYS的初始密码都为 oracle Container SSH 的 root 密码为admin。 需要说明的是，在 OS X 上通过 SSH 连接 docker container 使用的是 docker 的 ip 而不是 localhost。 安装完毕之后，就可以通过客户端配置上述数据库信息来连接数据库了。图为 OS X 下 SQL Developer 连接 Docker 中数据库的配置界面。","link":"/2015/03/20/Oracle-on-Docker/"},{"title":"RxAndroid学习路线","text":"最近在看函数响应式编程，感觉学习过程酸爽不过确实在异步操作等方面相对于传统方式优雅到爆，这里分享一些国内外不错的文档。 官方文档 官方文档中文翻译 NotRxJava懒人专用指南 深入浅出RxJava（一：基础篇） 深入浅出RxJava（二：操作符） 深入浅出RxJava（三：响应式的好处） 深入浅出RxJava（四：在Android中使用响应式编程）","link":"/2015/09/03/RxAndroid学习路线/"},{"title":"Dagger 2 中 Scope 用法","text":"Dagger 2 简介Dagger 2 是 Google 对 Square 下的项目 Dagger fork 出来的 Android IoC 框架，替换了原 Dagger 的反射使用代码生成进行注入，并添加了一些新特性。 @ScopeDagger 1 中对注入对象的的注解只有 Singleton，而 Dagger 2 中可以使用 Scope 自定义注解来指定注入对象的作用域，来实现局部单例的效果。看了很多介绍文档都不是很清楚，使用 find usage 发现并没有生成代码对注解进行监听，推测 Scope 是影响了代码生成的结果。这里举个例子来说明如何使用 Scope 注解。 （参考问题：http://stackoverflow.com/questions/29923376/dagger2-custom-scopes-how-do-custom-scopes-activityscope-actually-work） 首先，Dagger 2 中为注解了自定义 Scope 的 Component 里每一个 Module 中的 Provider 都创建了一个实例。因此在一个 Module 中想要获得一个单例的 Provider，你需要指定 Module 中 Provider 方法的为自定义的 Scope。 123456789@Modulepublic class YourModule { @Provides @YourScope // 每个 component 一个实例 public Something something() { return new SomethingImpl(); } @Provides // 每次注入创建一个新实例 public Otherthing otherthing() { return new OtherthingImpl(); }} 12345678@Component@YourScopepublic interface YourComponent { Something something(); Otherthing otherthing(); void inject(YourThing yourThing);} 也有人指出，本质上一个 Scope 只能确定自身和其他 Scope 是不同的，所以使用 Component 的依赖也可以创建一个二级 Scope。 123456@Modulepublic class SubModule { @Provides @SubScope public ThatThing thatThing() { return new ThatThingImpl(); }} 1234567@Component(dependencies={YourComponent.class}, modules={SubModule.class})@SubScopepublic interface SubComponent extends YourComponent { ThatThing thatThing(); void inject(SubThing subThing);} 另外一个 Component 只可以依赖一个其他 Scope 的 Component。","link":"/2016/01/15/Scope-In-Dagger-2/"},{"title":"自动生成 ContentProvider 注解框架 Schematic","text":"ContentProvider 是 Android 四大组件之一，主要负责应用内数据库实例的管理，是系统提供的有效管理数据库实例的方式之一。虽然在官方文档中有说过：「如果应用不向外部提供数据，可以不必使用 ContentProvider」，但出于它的一系列好处，我们仍然偏爱于建立 ContentProvider 来管理数据库。不过 ContentProvider 的代码比较繁琐而且格式单一，所以就促使一些类库的产生，今天就发现了一个不错的可以自动完成 ContentProvider 大部分工作的注解框架：Schematic。 项目地址：https://github.com/SimonVT/schematic本文仅为翻译 简介自动生成一个由 SQLite 数据库支持的 ContentProvider。 用法首先根据数据库中一张表创建一个包括表中所有列的类。 123456public interface ListColumns { @DataType(INTEGER) @PrimaryKey @AutoIncrement String _ID = \"_id\"; @DataType(TEXT) @NotNull String TITLE = \"title\";} 然后创建一个数据库类（使用框架中的注解方法）使用刚刚创建的包括列的类。 1234567@Database(version = NotesDatabase.VERSION)public final class NotesDatabase { public static final int VERSION = 1; @Table(ListColumns.class) public static final String LISTS = \"lists\";} 最后定义一个 ContentProvider 12345678910111213@ContentProvider(authority = NotesProvider.AUTHORITY, database = NotesDatabase.class)public final class NotesProvider { public static final String AUTHORITY = \"net.simonvt.schematic.sample.NotesProvider\"; @TableEndpoint(table = NotesDatabase.LISTS) public static class Lists { @ContentUri( path = Path.LISTS, type = \"vnd.android.cursor.dir/list\", defaultSort = ListColumns.TITLE + \" ASC\") public static final Uri LISTS = Uri.parse(\"content://\" + AUTHORITY + \"/lists\") } 加入到你的项目中我推荐使用 android-apt 插件。它不会把编译器构建打包进最终的 apk 中，并且也会设置源码路径，这样 Android Studio 就可以找到生成的 class 文件。 项目配置文件对应位置加入： 1234567dependencies { classpath 'com.neenbedankt.gradle.plugins:android-apt:1.7'}repositories { mavenCentral()} module 配置文件对应位置加入 1234567apply plugin: 'com.android.application'apply plugin: 'android-apt'dependencies { apt 'net.simonvt.schematic:schematic-compiler:0.6.3' compile 'net.simonvt.schematic:schematic:0.6.3'} 原文中作者并没有给出确切的版本，这里的版本仅仅作为参考。 LicenseCopyright 2014 Simon Vig Therkildsen Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","link":"/2015/09/07/Schematic/"},{"title":"OS X（10.9及以上）中启动 Web 和 php 服务器","text":"拖了好几大月，php 终于要动工了，第一步当然是搭环境。然后 OS X 用户的一大福利是 php 环境系统已经集成了。记得刚买电脑时的 OS X 10.8 还可以在设置共享中直接开启 Web 服务器，貌似10.9之后就没有了，不过这个功能并不是被阉割了，可以使用以下方法来启动 OS X 预装的 Apache 服务器： sudo apachectl start和 Linux 中一样，终止和重启服务器的命令如下： sudo apachectl stop sudo apachectl restart 之后便可以在浏览器里登录 localhost 或者 127.0.0.1 测试是否启动成功了 php 也是预装好的，通过修改 /etc/apache2/httpd:conf 来启用：找到 #LoadModule php5_module libexec/apache2/libphp5.so 将前面的#号去掉，然后重启 Apache 服务器就可以了。 然后再配置一下 DocumentRoot 目录，就可以用了。","link":"/2014/10/05/StartPhpOnOSX/"},{"title":"TIPS000","text":"我年纪越大，就越觉得那些心理阴暗，一肚子心计，满脑子阴谋论的人，是因为智力不够。这和我小时候的认识是大致相反的。尽管存在个体差异，但是整体上，足够聪明的，进化得更好的人群，通常会倾向于选择公平、正义，更容易具有坦诚、善良的品质。","link":"/2015/01/21/TIPS000/"},{"title":"TIPS","text":"As the Secretary General of the United Nations, an organizations of the 147 member states who represent almost all of the human inhabitants of the planet earth. I send greetings on behalf of the people of our planet. We step out of our solar system into the universe seeking only peace and friendship, to teach if we are called upon, to be taught if we are fortunate. We know full well that our planet and all its inhabitants are but a small part of the immense universe that surrounds us and it is with humility and hope that we take this step. 作为联合国秘书长，一个拥有147个成员国，代表了几乎所有地球居民的组织， 我向你们送去全人类的问候。我们走出太阳系的家门进入这宇宙，只为寻找和平和友谊，抑或应邀倾囊相授，抑或有幸聆听教诲。我们很清楚，我们星球及上面的所有生灵，只不过是这广阔宇宙中微小的一部分。我们谦卑而满怀希望地迈出这一步。 —— 1977 库尔特·瓦尔德海姆","link":"/2015/09/24/TIPS/"},{"title":"TIP003","text":"True Nobility In a calm sea every man is a pilot. But all sunshine without shade, all pleasure without pain, is not life at all. Take the lot of the happiest—it is a tangled yarn. Bereavements and blessings, one following another, make us sad and blessed by turns. Even death itself makes life more loving. Men come closest to their true selves in the sober moments of life, under the shadows of sorrow and loss. In the affairs of life or of business, it is not intellect that tells so much as character, not brains so much as heart, not genius so much as self-control, patience, and discipline, regulated by judgment. I have always believe that the man who has begun to live more seriously within begins to live more simply without. In an age of extravagance and waste, I wish I could show to the world how few the real wants of humanity are. To regret one’s errors to the point of not repeating them is true repentance. There is nothing noble in being superior to some other man. The true nobility is in being superior to your previous self. 风平浪静的大海，每个人都是领航员。 但是，只有阳光而无阴影，只有欢乐而无痛苦，那就不是人生。以最幸福的人的生活为例—它是一团纠缠在一起的麻线。丧母之痛和幸福祝愿彼此相接，是我们一会伤心，一会高兴，甚至死亡本身也会使生命更加可亲。在人生的清醒的时刻，在哀痛和伤心的阴影之下，人们真实的自我最接近。 在人生或者职业的各种事务中，性格的作用比智力大得多，头脑的作用不如心情，天资不如由判断力所节制着的自制，耐心和规律。 我始终相信，开始在内心生活得更严肃的人，也会在外表上开始生活得更朴素。在一个奢华浪费的年代，我希望能向世界表明，人类真正需要的的东西是非常之微少的。 悔恨自己的错误，而且力求不再重蹈覆辙，这才是真正的悔悟。优于别人，并不高贵，真正的高贵应该是优于过去的自己。","link":"/2015/04/03/TIPS003/"},{"title":"TPB AFK 现实中的海盗湾","text":"转自阮一峰的博客 2009年4月1. 几个小时前，传来一条重大的消息。 瑞典一家法院今天以侵权罪为由，判决海盗湾(Pirate Bay)四名运营者各入狱1年，并向受到版权侵害的媒体公司赔偿360万美元。 2. 海盗湾（The Pirate Bay，简称TPB）是世界上最大的BT下载网站之一，全球用户接近2200万。去年1月31日，瑞典检察官对”海盗湾”提起刑事诉讼，控告网站的4名管理者”协助他人侵犯版权”（promoting other people’s infringements of copyright laws），要求将他们判决2年有期徒刑。听到这个消息，许多电影公司和唱片公司也纷纷提起民事诉讼，总计要求海盗湾赔偿1800万美元。 今年2月16日，这个案子在斯德哥尔摩第一次开庭。2周后的3月3日，全部庭审结束。今天上午11点，宣布判决。 Fredrik Neij（1978年4月27日—-） 身份：海盗湾创始人。 判决：入狱一年，罚款90.5万美元。 Gottfrid Svartholm（1984年10月17日—-） 身份：海盗湾创始人。 判决：入狱一年，罚款90.5万美元。 Peter Sunde（1978年9月13日—-） 身份：海盗湾程序员兼发言人。 判决：入狱一年，罚款90.5万美元。 Carl Lundstrom（1960年4月13日—-） 身份：海盗湾资助者。 判决：入狱一年，罚款90.5万美元。 3. 虽然一审被判有罪，但是并不意味4名被告马上就要服刑。他们可以不断上诉，最高法院的最终判决需要几年时间。 海盗湾网站暂时也没有被关闭的危险，因为服务器据说存放在瑞典境外的一个秘密地点。据有讽刺意味的是，这场判决没有打倒海盗湾，反而使它变得更流行了。由于关注的人太多，瑞典国家电视台为庭审提供了在线直播的Feed，这是历史上的第一次。在审判开始后的短短几周内，瑞典盗版党的党员人数增加了50%，它下属的青年组织已经是瑞典国内第二大的政党青年组织。在6月份即将开始的欧洲议会选举中，瑞典盗版党很可能破天荒地获得议席。 目前还看不出，这个判决对全球性的BT下载有何影响。由于BT协议与生俱来的开放性，所以哪怕最终”海盗湾”关门歇业，BT下载服务在网上依然将随处可得。也许正如宣判前，Peter Sunde在twitter上所说的：”请镇定。海盗湾不会有事的，不管我们个人还是网站都是这样。一切都是演给媒体看的。”（Stay calm - Nothing will happen to TPB, us personally or file sharing what so ever. This is just a theater for the media.） 4. 这样一场全球瞩目的审判，国内关注的人却不多。我一度想在网志上连载报道，但是无奈精力不够，后来也没有跟进。 这场审判的重大意义早已超出了海盗湾本身，它涉及到了一个重大问题—-BT下载中的Tracker服务器是否侵权？（简单说，Tracker服务器的作用，就是为不同下载者牵线搭桥、让他们彼此建立起联系，它本身并不储存内容文件。） 这个问题是庭审中的焦点，我不是法律专家，也没有仔细看双方的庭审记录，所以在这里我不打算对此发表看法。 我只是想说，这个案件反映了目前的版权制度必须做出改革。网络技术的发展，使得信息的分享变得空前的便利，版权制度应该顺应变革的潮流，而不是成为变革的障碍。 5. 除了版权制度以外，另一个需要改变的对象是北京政府。海盗湾在中国一直被屏蔽，不仅是网站本身被屏蔽，更重要的是tracker服务器也被屏蔽了。这样有什么后果？网上一半左右的torrent文件，使用的是海盗湾的tracker，它们在中国都无法进行BT下载，因为我们连不上tracker服务器。这意味着中国人民无法接触到世界上50%的BT资源。 这是很严重的后果，它阻碍了中国人民获得知识和信息的步伐，是对整个民族的犯罪。我希望北京政府能认清楚自己到底在干什么。 6. 我本人一直是海盗湾、BT下载，乃至整个开放源码运动的坚定支持者，从来没有动摇过。（参见我的旧文《比尔.盖茨和理查德.斯托曼》。） 我并不是在说我支持盗版，而是在说我支持知识的分享。全世界有那么多海盗湾的支持者，我相信其中大多数人都有同样的想法：目前的版权制度收费太高，阻碍了知识的传播，已经背离了鼓励原创者的初衷，而成为了大公司高额垄断利润的来源。 我从心底里相信，虽然海盗湾有一些与现行版权法不相容的地方，但是从根本上说，它是一项正义的和建设性的事业，是对全人类有益的，象征着技术变革的方向。海盗湾的存在，会让世界变得更好，而不是更坏（也许目前的版权法就能起到这个作用）。让我们拭目以待这个案件会怎样发展。（完） 纪录片下载","link":"/2015/01/10/TPB-AFK/"},{"title":"多版本 Android Studio 共存[译]","text":"现在同时安装多个版本的 Android Studio 已经成为可能。当我们提供 Canary 版本（或者 Beta 版本）的下一版本 IDE 时，你也许想安装这个新版本但并不想替换掉你原有的稳定版。 Android Studio 在一个特殊文件夹保存它的设置；这个实际位置取决于操作系统（和 IDE 的版本），比如，如果你同时安装了 Android Studio 1.5.1 和 Android Studio 2.0 Preivew1，它们将各自读取位于 ~/.AndroidStudio1.5 和 ~/.AndroidStudioPreview2.0 的配置. 所以，一旦你安装了这两个版本，你可以直接使用它们，甚至是一起使用，并且它们不会互相冲突。（注意：新版本也许会改变你项目中的配置数据，比如在 .idea 中的 code style） 注意在 OS X，你通常从 dmg 文件夹中拖拽 Android Studio 的 app 进行安装。这样做会在新版本安装的同时替换掉前一个版本。想要避免这个问题，请先重命名已有版本的 app，比如把 「Android Studio」改为「Android Studio 1.5」 删除旧的设置文件夹 一旦你用的旧版本迁移完成后，你可以删除这个版本的设置文件夹。它可以腾出大量的磁盘空间，尤其是索引缓存。 视频：https://www.youtube.com/watch?v=SBbWGxXCMqQ 原文：http://tools.android.com/tips/using-multiple-android-studio-versions","link":"/2016/01/24/Using-Multiple-Android-Studio-Versions/"},{"title":"在 hexo 的 source 文件夹下添加 html 文件方法","text":"想要添加 html 文件而不被 hexo generate 生成，可以在 html 文件的最上面添加123---layout: false--- 来完成。比如自己定制的 404 页面，或者 Google 搜索引擎的验证页。","link":"/2014/02/18/add_html_without_generate/"},{"title":"Android 启动模式（LaunchMode）","text":"Android 中 Activity 启动模式决定了 Activity 启动时对 Activity 栈的行为，在推送打开、拦截登录等常见的业务逻辑下很实用。这里再简单总结一下。 LaunchMode 是在 Manifest 文件中的 Activity 标签下定义的，属性名就是 launchMode，共有四个值：Standard、SingleTop、SingleTask 和 SingleInstance。其中 Standard 是默认的，即如果没有标注这个属性，这个 Activity 就是以 Standard 模式启动的。 用点菜的比喻总结一下。activityClass 相当于菜单，task 栈相当于一张桌子，每张桌子只有一个盘子大小，因此要想放多个菜盘子是叠起来的。 Standard 模式Standard 模式下，用菜单点一个菜就上一盘新的(create)，放到你的桌子的最上面，每点一个菜就盖在前一个菜的最上面。 Standard 根据 activityClass 创建一个实例，添加到当前 task 的栈顶。不过测试发现如果当前处于其他 task，创建的 activity 仍然会处于原来的 task 栈 SingleTop 模式SingleTop 模式下，上这个菜时，服务员会看一下你桌子上的最上面这个菜是不是这个菜，如果是，就不上了（onNewIntent）；如果不是，再加一盘在这个桌子的最上面。 SingleTop 只有在这个 activityClass 的实例在当前的栈顶时，不会创建 activity，只是调用 onNewIntent 方法。其他情况下还是会创建 activity SingleTask 模式SingleTask 模式下，服务员上这盘菜时，会翻起来看每个盘子有没有这个菜，如果有，把这个菜上面的菜都拿走（destroy）。 SingleTask 如果发现栈里有该 activity，清空该 activity 上层的 activity，使这个 activity 重新处于栈顶。这里测试的确实是这样，当启动了 SingleTask 的 activity 后，再启动 N 个其他 activity，然后再启动 SingleTask activity，相当于前面 N 多 activity 全都 destroy 了。 SingleInstance 模式SingleInstance 模式下，服务员会给你找个新桌子，这个桌子只能放这个 activity 一盘菜。当上这盘菜时系统会检查有没有这个菜的桌子，有的话直接搬到你面前，没有的话再去找张桌子放下。 SingleInstance。创建另外一个任务栈并且在这个栈中只放自己，不允许其他 Activity 进入。这个模式在任何情况下都不会重复创建 Activity。","link":"/2016/06/07/android-launch-mode/"},{"title":"Android 版本分布","text":"Google 官方的数据，7天为一个统计周期：应该没有比这个更官方的了 https://developer.android.com/about/dashboards/index.html","link":"/2017/03/22/android-version-statistics/"},{"title":"Android应用中短信的访问","text":"首先在 AndroidManifest.xml 文件中添加代码 &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt; 然后在程序代码中添加 private static final Uri SMS_ALL = Uri.parse(&quot;content://sms&quot;) 在需要访问的地方 Cursor c = context.getContentResolver().query(SMS_ALL, null, null, null, null);` cursor结构： 0._id 1.thread_id 2.address 3.person 4.date 5.date_sent 6.protocol 7.read 8.status 9.type 10.reply_path_present 11.subject 12.body 13.service_center 14.locked 15.error_code 16.seen","link":"/2014/01/23/android应用中短信的访问/"},{"title":"Intellij IDEA 下调试 Annotation Processor 代码的配置","text":"Annation Processor 是 Java 中静态分析注解并在预编译期生成代码常用的一个技术，因为不属于运行时代码，所以调试起来和普通代码有些不同，这里记录一下调试 Annotation Processor 代码的方法(Intellij 或 Android Studio)。 123# 关闭 gradle daemon./gradlew --stop./gradlew --no-daemon -Dorg.gradle.debug=true :app:clean :app:compileDebugJavaWithJavac 新建 Remote 运行配置： 12345-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005-Xnoagent -Djava.compiler=NONE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 1localhost 5005 先运行 Remote，再运行 connectedCheck（debug 模式的 gradle 任务），就可以切入断点了。 参考资料：https://blog.xmartlabs.com/2016/03/28/Debugging-an-Annotator-Processor-in-your-project/","link":"/2017/03/21/annotation-processor-debug-in-intellij/"},{"title":"Jenkins 中如何让 Android SDK 根据需要自动更新","text":"每次项目中切换了新的 support，总是要登录构建服务器更新一下 SDK，很麻烦。其实 Jenkins 本身是支持自动更新的，稍微留一下会发现，构建时不存在的 SDK 的报错信息为： You have not accepted the license agreements of the following SDK components: … 原来是 license 问题，需要手动去 agree 才能进行下一步，所以就中断了。但其实是可以跳过的，Stackoverflow 上有人引用了 Jake Wharton 给出了方法： 123mkdir &quot;$ANDROID_SDK/licenses&quot; || trueecho -e &quot;\\n8933bad161af4178b1185d1a37fbf41ea5269c55&quot; &gt; &quot;$ANDROID_SDK/licenses/android-sdk-license&quot;echo -e &quot;\\n84831b9409646a918e30573bab4c9c91346d8abd&quot; &gt; &quot;$ANDROID_SDK/licenses/android-sdk-preview-license&quot; 上面的哈希字符串据说是 license 文本的 sha1，所以如果 license 换掉的话也会失效。暂时这样用吧。 参考：http://stackoverflow.com/questions/38096225/automatically-accept-all-sdk-licences","link":"/2016/11/18/auto-update-android-sdk-on-jenkins/"},{"title":"GitLab CI 配置构建 Android 项目","text":"标准步骤 配置 GitLab Runner 添加配置文件。.gitlab-ci.yaml 文件规则 https://docs.gitlab.com/ce/ci/yaml/ 可以参考官方提供的文档来试试 https://about.gitlab.com/2016/11/30/setting-up-gitlab-ci-for-android-projects/ Android 实践中的改进如果你真正把官方给出的配置拿来构建就会发现，虽然配置起来方便，配置文件也足够简洁，但是每次都需要安装一次 SDK。真实实践中最好保留 SDK 和 gradle 缓存以及编译缓存，这样可以开启增量编译和避免每次下载同样的东西，有助于持续化构建时减少单次的构建时间，。 使用 cache 保留每次构建缓存使用 cache 的功能类似于 exclude 一个 volume，不过原理不同，根据日志推测 GitLab 是将指定的文件打包存储起来并在下一次释放而已。 1234567cache: key: ${CI_PROJECT_ID} paths: - .gradle/ - build/ - ${MODULE_NAME}/build/ - ${ANDROID_HOME}/extras/ 其中 CI_PROJECT_ID 是以项目 ID 作为键存储，因为 Runner 可能是多个项目共用的，而多个项目在该需求想不能共享构建的缓存，所以要以项目 ID 分别存储缓存。 使用 artifacts 保留每次构建结果和 Jenkins 中的 artifacts 功能一致，都是用来保存构建结果用的，指定对应的目录即可。在 Android 中输出目录是比较深的，可以在 script 中转移到浅层目录对于输出文件展示来说可能更直观一些。例如： 12345678script:- mkdir -p apk- rm -rf app/build/outputs/apk/- ./gradlew sample:assembleRelease- cp sample/build/outputs/apk/*.apk apk/artifacts: paths: - apk/*.apk 使用定制的 docker 镜像进行构建定制的镜像下载通常所需的 SDK 组件，这样构建项目时就不需要临时下载了。这里我使用的是别人分享的一个 Dockerfile，项目地址是：https://github.com/jangrewe/gitlab-ci-android 。作者把需要下载的依赖包放到一个 txt 文件中，你可以根据需要修改经常使用的 SDK 以及依赖版本编译自己的 image。这里和 jenkins 中使用有所不同，一旦你需要升级 SDK 版本或者依赖版本，就要重新编译一个新的镜像。 修改镜像拉取策略修改配置文件：/etc/gitlab-runner/config.toml 在对应 runner 节点下添加 pull_policy = &quot;if-not-present&quot; 就可以了。例如： 123456789101112131415[[runners]] name = &quot;Android Build Runner&quot; url = &quot;https://rasp.xyz/git/&quot; token = &quot;3dc54666cacafdd6efad73cb73fc3e&quot; executor = &quot;docker&quot; [runners.docker] tls_verify = false image = &quot;alpine:latest&quot; privileged = false disable_cache = false volumes = [&quot;/cache&quot;] shm_size = 0 // 加入这行 pull_policy = &quot;if-not-present&quot; [runners.cache] 默认的 GitLab Runner 是直接网络拉取镜像的。需要到配置文件中将策略改为先判断本地是否存在，本地不存在再从服务器拉取（pull）。 其他构建的触发条件如果没有配置的话，默认是任何分支的提交、合并以及 tag 的创建都会触发构建。这显然是有些浪费的。我目前的策略是仅主分支发生变动才会构建。只需要在配置的 job 节点下添加 only 值即可： 12345// Job 名称Build Release Version: // 只在主分支发生变动时构建 only: - master 这样我一般开发时就是用 develop 分支，开发完毕没有问题了合并到主分支就会自动进行构建。不过 GitLab CI 默认情况下构建成功是没有邮件通知的(相比于 travis)，应该是可以配置的。我目前是用了 Telegram 的 REST Api 直接发送给我的 Telegram 账号通知，配置起来也十分方便。 总结GitLab CI 总体来说还是比较好用的，虽然在易用性和生态上不如 Jenkins，但是实际使用时考虑到免不了一些自定义配置的话 jenkins 也很麻烦。目前使用的主要痛点在于构建的 docker 不能指定共享目录(volume)，导致 SDK 升级和自动下载不如 jenkins 方便。另外 Web UI 的可操作性也不如 Jenkins。刚刚这两点考虑到前者还可以接受，后者的话也决定减少使用 Web 来控制构建流程，所以还是准备在个人项目上迁移到 GitLab CI 的。GitLab 官方似乎也比较看重这个项目，希望生态能够越来越强大。","link":"/2017/07/10/build-android-project-with-gitlab-ci/"},{"title":"Android 项目的 Jenkins 参数化构建","text":"需求描述项目分为三种类型构建： 测试环境构建 debug 测试环境构建后上传内测平台 (fir.im) 发布版构建 release 三种构建类型在完成后都保存构建输出的 apk，只有在类型 2 完成后执行上传到内测平台操作 当前环境在配置参数化之前，已经具有基础的 jenkins 构建环境，jenkins 只支持一种类型的构建，每次需要构建不同类型的版本需要手动去改动的 invoke gradle script 中的 tasks 来实现。上传 fir.im 使用了 fir.im 官方提供的插件，在构建完成后直接上传对应目录的 apk 文件，如果不需要上传需要手动删除该步骤。 进行的改动打开 jenkins 中需要改动的项目的「配置」界面。 jenkins 中的配置 勾选「General」中的「参数化构建」选项，添加参数，选择 Choice。然后在依次在 name，choices，description 中填写，参数名，可选的参数选项和该参数的说明。例如我这里添加的 name 为 build_type，choices 为 test, test_fir, release(每一行代表一种 build type)。 删除掉「构建」中的「Invoke Gradle Script」，因为需要针对参数进行处理所以自带的调用 gradle 脚本不能满足需求，这里选择「Execute Shell」类型添加，并在 Command 中填写： 1234567891011121314151617echo \"构建类型 $build_type\"chmod +x gradlewcase $build_type in test) ./gradlew clean assembleDebug ;; test_fir) ./gradlew clean assembleDebug ./gradlew app:publishApkDebug ;; release) ./gradlew clean assembleRelease ;; *) exit ;;esac 删除构建完成后的 fir.im 上传。因为 fir.im 官方的插件也没有提供参数化构建的支持，所以这里改用官方提供的 gradle 构建插件，通过在 shell 中判断参数来决定是否调用上传脚本。 项目中的配置项目中的配置主要是配置 fir.im 的 gradle 插件，可以参考官方的说明 http://blog.fir.im/gradle/ 。这里也简单描述一下步骤 项目级别 build.gradle 添加以下配置： 123456789101112131415buildscript { repositories { // ... jcenter() // 添加fir maven源 maven { url \"http://maven.bughd.com/public\" } } dependencies { classpath 'com.android.tools.build:gradle:2.2.0' //添加fir插件依赖 classpath 'im.fir:gradle-fir-publisher:1.0.7' }} 在 module 级别 build.gradle 添加如下配置： 123456789apply plugin:'im.fir.plugin.gradle'// 必填fir { //必填 上传 fir.im apk 字段，否则无法上传 APP 到 fir.im apiToken '替换为你的 fir.im API_TOKEN' //可选 上传fir.im 中显示的changelog changeLog '替换为你的更新日志'} 使用参数进行构建配置完成够，会发现 jenkins 项目视图下的「立即构建」编程为使用参数进行构建。点击后会让用户选择三种构建类型，这里选择 test_fir 就可以构建并且上传到 fir.im 了。其他两种类型则会构建后归档构建结果。定制其他类型的构建同理。 额外的尝试使用 gradle 插件已经上传之后，定制化是方便了一些，但是相应的 changelog 这个参数不太好传入了，因为是在 gralde 配置中的固定字符串。因为需要在上传的时候标记这个包是线上环境还是测试环境，所以为了定制这个 changelog 又进行了以下尝试： 使用 gradle.properties。 在 module 的 gradle 配置中，fir 的 changeLog 使用一个变量来表示： 1changeLog \"$change_log_string\" 之后在 jenkins 执行 gradlew 之前，通过追加的方式把这个变量添加到配置文件中： 1echo '\\nchange_log_string=测试环境\\n' &gt;&gt; gradle.properties 之后发现一个比较头疼的问题：gradle.properties 中定义的配置中文会乱码，尝试修改了很多地方的配置，最后在本地测试也是同样乱码，通过搜索知道可能需要对 unicode 字符进行 encode 之后才行，觉得这样影响本身文本的可读性就放弃掉了 动态追加 module 的 build.gradle。 这种方法相比相面的，虽然不怎么优雅，但是简单粗暴而且不会乱码。方法通常简单，在需要上传 fir 的任务执行之前用追加上 fir 的配置： 1234567export FIR_TOKEN=\"这里放你的 token\"export CHANGE_LOG=\"测试还是线上环境\"echo '\\n' &gt;&gt; app/build.gradleecho 'fir {\\n' &gt;&gt; app/build.gradleecho \"apiToken '$FIR_TOKEN'\\n\" &gt;&gt; app/build.gradleecho \"changeLog '$CHANGE_LOG'\\n\" &gt;&gt; app/build.gradleecho '}\\n' &gt;&gt; app/build.gradle 相应的，在项目的配置里就不需要配置 fir 的 dsl 了，否则也会造成错误","link":"/2016/11/02/build-android-project-with-params/"},{"title":"Chrome书签图标不显示以及关闭自动更新的方法","text":"最近在OS X Mavericks 上升级 Chrome 30之后发现频繁崩溃，查找查找相关资料发现属于 Chrome 的bug，所以在先退回29。遇到 Chrome 书签不显示（比如在手动升级直接替换app文件的时候），可以删除位于 Library/Application\\ Support/Google/Chrome/Default/ 的 Favicons 文件后重启浏览器解决。 删除 Favicons rm Library/Application\\ Support/Google/Chrome/Default/Favicons 关闭 Chrome 自动更新 defaults write com.google.Keystone.Agent checkInterval 0 （PS: 新版本已经修复这个问题）","link":"/2013/10/12/chrome书签图标不显示/"},{"title":"关于 Android 背景色 Alpha 值的一个坑","text":"这是公司项目一个留了很久的 bug，尝试找了很多次原因都没有头绪。这个 bug 是这样的： 定义了一个主题色为例如 #FF0000，很多界面控件都用了这个颜色。可是这个颜色在 app 使用过程中用着用着就会出现变成了透明的情况，而且出现透明之后，所有使用这个颜色的控件都会变成透明。 更奇怪的是，重启应用会恢复这个问题，但是操作一会儿又会出现。项目有个随着页面滚动标题栏从透明过渡到主题色的界面实现，类似于 Design 库中 AppBar 的那种效果。实现方法是这样的： // 滚动监听器 伪代码 someParams -&gt; { //... view.getBackground().setAlpha(percent); //... } 今天「代码级复用」这一 feature 时，发现把 bug 也引入了新项目，才发现这个实现的问题之所在…… 首先，view.getBackground() 获得的是一个 ColorDrawable，然后给这个 ColorDrawable 设置 Alpha 值的话，会影响所有设置 background 为这个颜色的背景色的 Alpha 值。 然后就写了个小 demo 验证了一下这个说法，虽然不是立即生效的，然后返回退出应用后，两个相同颜色背景的 view，改变其中一个确实会影响到另一个。 当时反应就是：WTF？难不成全局的相同颜色的 Drawable 都是同一个对象？不过很快打印了一下 background 的 drawable 对象验证了并不是这样——虽然这些 view 获得的 ColorDrawable 的 Alpha 值都相同，但 hashcode 都是不同的。 所以我更倾向于这是 Android 内存优化带来的 bug，即使这个颜色在定义时就有 Alpha 值，在修改后也会被忽略，并影响到其他的 view。该问题只在布局文件里设置 background 为一个 color 的 id 或者值，或者 setBackgroundResource 为一个 color 时存在。如果使用 new ColorDrawable(int) 来构造一个使用相同颜色值的对象则不受影响，我目前也正是使用这个方法来躲避掉这个 feature。 UPDATE： 发现文档里有这个方法，验证了之前的说法，从同一资源加载的 drawable 确实会共享状态，不过有一个 mutate 方法来禁用这一特性。文档如下： Drawable mutate () Make this drawable mutable. This operation cannot be reversed. A mutable drawable is guaranteed to not share its state with any other drawable. This is especially useful when you need to modify properties of drawables loaded from resources. By default, all drawables instances loaded from the same resource share a common state; if you modify the state of one instance, all the other instances will receive the same modification. Calling this method on a mutable Drawable will have no effect. 翻译： Drawable mutate () 让一个 Drawable 变为 mutable 的。这个操作是不可逆的。一个 mutable 的 drawable 可以保证不会分享自己的状态给其他 drawable。当一个 drawable 是从 resource 加载的，在需要更改它状态时这个方法特别有用。在默认情况下，所有从相同 resource 的 drawable 的实例是共享一个通用状态的；如果你修改了其中一个的状态，所有其他的实例也会收到相同的改动。在一个已经是可变的 drawable 上调用该方法没有效果。 所以，上述代码只要在 drawable 获取之后，调用一下 mutate() 方法即可。","link":"/2017/01/12/colordrawable-bug/"},{"title":"在某些图片上禁用 fancybox","text":"fancybox 这玩意儿挺不错的，不开启它的话，在点击图片的时候，时常会突兀的跳转到一个图片的页面上，体验很不好。 但是有些情况下，也希望 某些图片不使用 fancybox 的幻灯片效果（比如本博个人简介中的头像），在 hexo 中可以这样实现： 找到 主题文件夹下的 script 文件，比如 landscape-plus 就是 themes/landscape-plus/source/js/script.js,找到这段： 123456789101112131415// Caption$(&apos;.article-entry&apos;).each(function(i){ $(this).find(&apos;img&apos;).each(function(){ if ($(this).parent().hasClass(&apos;fancybox&apos;)) return; var alt = this.alt; if (alt) $(this).after(&apos;&lt;span class=&quot;caption&quot;&gt;&apos; + alt + &apos;&lt;/span&gt;&apos;); $(this).wrap(&apos;&lt;a href=&quot;&apos; + this.src + &apos;&quot; title=&quot;&apos; + alt + &apos;&quot; class=&quot;fancybox&quot;&gt;&lt;/a&gt;&apos;); }); $(this).find(&apos;.fancybox&apos;).each(function(){ $(this).attr(&apos;rel&apos;, &apos;article&apos; + i); });});if ($.fancybox){ $(&apos;.fancybox&apos;).fancybox();} 在if ($(this).parent().hasClass('fancybox')) return;下插入if ($(this).hasClass('nofancybox')) return;意思为如果遇到 nofancybox 类则跳过，这样在不需要 fancybox 显示 img 标签上的 class 改为 nofancybox 就可以禁用 fancybox 了。","link":"/2014/08/12/disable-fancybox/"},{"title":"Docker 小试","text":"使用 Docker 照着别人教的把 oracle 装好了，但是对 docker 一些基本的用法还不熟悉，比如：我配置好一个 container，如何打包给别人直接用，如何如何查看 container 的状态等等。这里在网上以及官方文档中收集了一些常用的命令，供自己忘记时查阅使用。 首先安装不用说了，Docker提供了非常便捷傻瓜简单粗暴的安装方法，这点和恶心的oracle大不相同。 ##docker pull docker pull: Pull an image or a repository from a Docker registry server从 Docker 注册的服务器中拉取一个镜像或者库。 比如我上次安装时使用的 wnameless/oracle-xe-11g 就是一个别人做好的 image，通过这个命令可以拉取到本地。 ##docker run docker run: Run a command in a new container在一个新的容器中运行一个命令 在进行 docker pull wnameless/oracle-xe-11g之后，就可以运行如下命令来启动这个镜像，并作为一个container运行： docker run -d -p 49160:22 -p 49161:1521 wnameless/oracle-xe-11g -d 选项代表 Enable daemon mode，启动后台驻留模式 -p 进行端口映射。这里把 container 的端口22映射到 docker 的49160，把 1521 映射到 49161 wnameless/oracle-xe-11g 该镜像的名字 ##docker start/stop/restart 运行完 docker run 之后，可以看到 docker ps -a 中就多了一个容器。通过 stop/start/restart 可以停止启动重启该容器。 ##docker ps docker ps -a 通过此命令可以查看所有 docker container 的运行状态，包括 6 列信息： 列名 含义 CONTAINER ID 容器id IMAGE 镜像 COMMAND 运行的命令 CREATED 创建时间 STATUS 状态 PORTS 端口 NAMES 名字 ##docker images 查看所有 image -a 显示所有 image（默认只显示中间层） ##docker save/load Save an image to a tar archive/Load an image from a tar archive 保存一个镜像到 tar 归档文件/从一个 tar 归档中加载一个镜像 ##docker commit docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] Create a new image from a container’s changes 根据一个 container 的变化创建一个新的 image -a, --author=&quot;&quot; Author (e.g., “John Hannibal Smith hannibal@a-team.com“) --help=false Print usage -m, --message=&quot;&quot; Commit message -p, --pause=true Pause container during commit","link":"/2015/03/21/docker-basic/"},{"title":"借助 Docker 使用 Hexo","text":"去歧义：本文讲述的是 本来想命名为：在 Docker 中使用 Hexo，想想还是有区别的：一个是完全把 Hexo 博客 host 在一个 docker 容器里(顶多把 site 的目录映射到外部来)，一个是仅仅把 Docker 作为替代宿主机安装 Node 以及 Hexo 环境的隔离环境。这样本机就可以不用安装 node 以及 hexo 相关的环境，如果你有在多台机器上使用 Hexo 的需求，那么使用 Docker 来代替本地安装是个不错的选择。 Dockerfile 已经上传到 DockerHub，直接在 .zshrc 中添加两个 alias 即可。 12345678alias docker-hexo='docker run --rm \\-e USER_NAME=twiceYuan \\-e USER_EMAIL=twiceyuan@gmail.com \\-v \"$PWD:/blog\" \\-v \"/Users/twiceYuan/.ssh:/root/.ssh\" \\-p 4000:4000 twiceyuan/hexo-cli'alias hexo='docker-hexo hexo' 其中，替换掉 username 和 user email 两个变量，替换掉 .ssh 的路径就可以了。 使用时和在本地时一样。","link":"/2017/02/11/docker-hexo/"},{"title":"Android App 开发环境和线上环境共存的 gradle 配置小技巧","text":"前段时间考虑过一个问题：Android 开发者在供职公司开发一个 app，但是又需要在下班后使用这个 app 怎么办？一般公司的服务端都会区分线上和线下环境，在开发时使用开发的环境以免脏数据污染线上的环境，但开发环境收不到真实消息的推送，而下班后每次都卸载重装的话感觉又有些蛋疼。今天想到可以用设置 flavor 的方式解决这一痛点，分享一下这个方案的配置过程。 方案简单来说就是开发时使用另一个 applicationId。之所以之前没有想到这个方案，主要是之前对包名和 applicationId 两个概念产生了混淆。因为大部分情况下，Android App 的包名都是和 Application ID 相同的，这本身没什么问题，但是它们其实没有任何关系，所以为了解决上面所说的痛点，可以采用修改 applicationId 的方式来开发，而在需要输出版本给外部(测试、运维)时，采用原来的 applicationId。 然后为了尽可能的懒和不会出差错，比如输出的包是自己改过 applicationId 的，可以用 gradle 配置中的 flavor 来解决这个事情。flavor 常用被用于打渠道包，主要功能就是能预先设定一些常量配置，在项目中去读取这些常量来打包 apk。在 flavor 中，可以使用 applicationId [app id] 来指定某个 flavor 使用哪个字符串作为应用标识。 使用 resValue &quot;string&quot;, &quot;app_name&quot;, RELEASE_APP_NAME 配置应用名称的目的是在启动器中区分开发版和线上版，使用这种方法定义资源之后，要在原项目 strings.xml 中删除 app_name这个字符串资源，否则会有重复定义错误。 主要配置如下： 1234567891011121314151617181920212223242526final RELEASE_APP_NAME = \"线上版本\"final DEVELOP_APP_NAME = \"开发版本\"final RELEASE_APP_ID = \"com.twiceyuan.duplicatesample\"final DEVELOP_APP_ID = \"com.twiceyuan.duplicatesample.dev\"android { // ... 其他配置 defaultConfig { // 默认使用线上的，避免有遗漏没有配置的渠道错误输出开发的配置 applicationId RELEASE_APP_ID resValue \"string\", \"app_name\", RELEASE_APP_NAME // ... 其他配置 } productFlavors { dev { applicationId DEVELOP_APP_ID resValue \"string\", \"app_name\", DEVELOP_APP_NAME } prod { applicationId RELEASE_APP_ID resValue \"string\", \"app_name\", RELEASE_APP_NAME } }} 配置完成后，就可以装个公司线上版本的 app 来用了，每次开发执行安装到手机的将是另一个实例，只有在发布线上版本时才会运用原来的 application id（这时安装会覆盖），只要记得不要输出开发的 flavor 给外部就好了。我一般给开发用的 flavor 配置一些加速开发的工具或选项，例如一些调试工具的依赖，最低 SDK 兼容版本等，所以基本不会出现这个情况，即使出现也会第一时间被发现。 不过也有一些问题：在一些需要以包名做授权的地方读取的包名是错误的会导致无法正常操作，这个就需要针对各种 SDK 做处理了。对于这个有更好的解决方案再来分享。","link":"/2016/09/09/duplicate-android-app-config/"},{"title":"使用 Git 的 tag 管理 App 版本","text":"Android 应用开发到打包上线经常有这样的场景：需要上线了，打了个包，发现版本号没改；然后改了版本号，再打包，提交。为了方便以后定位版本，我们一般还会在发布后为这个版本打个 tag，这个 tag 会标记我们上线前的最后一次提交。 经过优化后，我们得到这样的流程：上线前确认版本的名称，比如 1.0。将 1.0 作为 tag 名称新建一个 tag 并推送，git 服务器通过 WebHook 触发 CI 构建这个版本的 APK，并根据 tag 名称来生成版本名(Version Name)，根据 tag 的数量生成版本号 (Version Code)；如果发现上线前仍需改动，直接删除这个 tag，修改提交直到达到上限标准后再次创建 tag，触发构建。 实现这个流程的第一步，就是在 gradle 中添加两个方法来获取版本名和版本号： 12345678910111213141516171819// 根据应用提交记录数来生成版本号def getAppVersionCode() { def stdout = new ByteArrayOutputStream() exec { commandLine 'git', 'tag', '--list' standardOutput = stdout } return stdout.toString().split(\"\\n\").size()}// 获取最新的 tag 名称def getLastTagName() { def stdout = new ByteArrayOutputStream() exec { commandLine 'git', 'describe', '--abbrev=0', '--tags' standardOutput = stdout } return stdout.toString().trim()} 之后修改 Application 应用中 android -&gt; defaultConfig 中的相关属性为方法获得： 12345678910android { //... defaultConfig { //... versionCode getAppVersionCode() versionName getLastTagName() //... } //...} 这样在执行 assemble 任务打包时，APK 的版本名和版本号都会从 git 的 tag 信息中获取（包括本地调试）。下一步就是解决 git 服务器出发的问题，这里 git 服务器和 CI 以最常见的 GitLab、Jenkins 为例。 首先在 Jenkins 的 Job -&gt; Configure 中打开 Trigger builds remotely。然后在 GitLab 在项目界面的 Settings -&gt; Integrations 中添加一个 Web Hook，URL 为 Jenkins 提供的 URL，Trigger 勾选 Tag Push Events。这样就完成了触发构建的流程。","link":"/2018/08/01/generate-app-versison-by-git-tag/"},{"title":"怎么在 hexo new 的时候自动打开创建的文档？","text":"看到作者 github 上有人问这个问题，然后作者给的方案： 在 script 文件夹下创建脚本文件，内容为： var exec = require(&apos;child_process&apos;).exec; hexo.on(&apos;new&apos;, function(target){ exec(&apos;open -a Mou &apos; + target); }); 我习惯使用 Mou 作为 markdown 的编辑器，当然你也可以换成自己喜欢的。这样在使用 hexo new创建新文档时就可以使用脚本中设置的编辑器自动打开了。 Hexo 3.0 之后失效，请参考 http://twiceyuan.com/2015/03/15/Hexo%E5%8D%87%E7%BA%A73-0/","link":"/2014/02/17/hexo_new_script/"},{"title":"Hexo 自动添加 Read More 标记","text":"hexo 在写作的时候，如果在文中添加&lt;!--more--&gt;则该标记之前的部分就会成为该文章的简述，显示在首页里。但自己一直感觉如果可以自行截取会更好，Google 了一下也有人有这样的需求，太没有贴出来具体的方法，在简单的学习了一下 JS 之后贴出自己的解决方案。在 hexo 的 github 上看到有人说是跟主题有关，费死八难找到了代码的关键部分：文件/themes/[主题名]/layout/_partial/article.ejs其中有一段为： 123456789101112&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (post.excerpt &amp;&amp; index) { %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link) { %&gt; &lt;p class=\"article-more-link\"&gt; &lt;a href=\"&lt;%- config.root %&gt;&lt;%- post.path %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;% } else { %&gt; &lt;%- post.content %&gt; &lt;% } %&gt;&lt;/div&gt; 从代码上看，post.excerpt 就是加了 more 标记之后的文章摘要，如果 post.excerpt 存在且在首页的话，则显示文章的摘要和「Read More」按钮。当不符合上述条件（post.excerpt 存在且在首页），就显示整个文章的内容 post.content。 因为我需要的是在文章里没有 more 标记时自动添加标记，所以需要改动的代码是要放在 else 后面的。我打算在文章没有 more 标记的时候，截取文章的前两段作为摘要，如果文章少于两段，则直接显示整篇文章内容。 所以代码大概是这样： 123456789101112var count = 0var content = post.contentwhile(count &lt; 4) { content = content.replace('\\n','x')}var br = content.indexOf('\\n') // 第一个换行符所在的位置if (br == -1 || !index) { // 如果不存在第一个换行符或者不在首页 post.content // 显示整篇文章} else { post.content.substring(0,br) // 截取到第二个换行符的位置 // 显示「Read More」按钮} 根据上述思路，修改后的代码为： 12345678910111213141516171819202122&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (post.excerpt &amp;&amp; index) { %&gt; &lt;%- post.excerpt %&gt; &lt;% if (theme.excerpt_link) { %&gt; &lt;p class=\"article-more-link\"&gt; &lt;a href=\"&lt;%- config.root %&gt;&lt;%- post.path %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;% } else { %&gt; &lt;% var br = post.content.indexOf('\\n') %&gt; &lt;% if(br &lt; 0 || !index) { %&gt; &lt;%- post.content %&gt; &lt;% } else { %&gt; &lt;%- post.content.substring(0, br) %&gt; &lt;% if (theme.excerpt_link) { %&gt; &lt;p class=\"article-more-link\"&gt; &lt;a href=\"&lt;%- config.root %&gt;&lt;%- post.path %&gt;#more\"&gt;&lt;%= theme.excerpt_link %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% } %&gt; &lt;% } %&gt; &lt;% } %&gt;&lt;/div&gt; 如果需要截取 N 个段落，则可以使用 replace 替换 content 里 N-1 次\\n然后使用 indexOf 即可。但是发现如果所要截取的部分有一半处于代码片段的话，就会很惨不忍睹。所以建议使用这种方法自动截取摘要的话，尽量为自己博客有代码的文章手动截取摘要。","link":"/2014/05/25/hexo自动添加readmore标记/"},{"title":"Let's Encrypt","text":"终于在免费方案的前提下搞定了博客的 HTTPS。之前试过 CloudFlare 的 CDN + HTTPS 的方案，最终因为速度实在太感人以及和 DNS 上和邮箱有冲突就放弃了；后来 Coding.net 也开放了自定义域名的 HTTPS 服务，试了以后感觉不错，但后来发现在 Android 设备上基本证书不可用，反馈了很久却迟迟没有解决。前两天又租了个乞丐版的搬瓦工 VPS，尝试了一下 Let’s Encrypt 感觉很方便，就试着自己搞了一下，恰好有发现 GitLab 的 pages 服务可以自己配置证书，所以借着 VPS 生成了一个证书然后配置在 GitLab 上。虽然速度貌似不如 Coding 的快，而且 ping 也被 GitLab 给屏蔽了，但总体还可以接受，暂时就先用这个方案了。 顺便解释下如果国内的朋友感觉访问本站太慢，那是因为用了 disqus 评论插件的问题，因为国内同类产品用了后实在不满意，最终还是选用了 disqus，需要评论请自备梯子。 UPDATE 2016 10 25：后来想起来很久之前买过一次 SSL 证书一直没用，打开看还有一个多月就过期了，但是试着激活了一下发现是从激活日开始算起的，还能再用一年，所以现在换成这个了。","link":"/2016/09/29/https-available/"},{"title":"源码安装配置 Nginx 记录","text":"debian 官方源中的 nginx 太旧了（1.6.x），想试试开启 HTTP2 和 TCP/UDP 负载均衡试试，需要 1.9 版本以上。换了 backports 的源一些相关模块总是安装不成功（←太菜），所以尝试了从源码安装，顺便体验一下最新的 nginx。 安装 Nginx 的依赖 PCRE 库 – NGINX 核心模块和 Rewrite 模块需要，并且提供了正则表达式的支持： 123456$ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz$ tar -zxf pcre-8.40.tar.gz$ cd pcre-8.40$ ./configure$ make$ sudo make install zlib 库 – NGINX Gzip 模块用来 header 压缩的： 123456$ wget http://zlib.net/zlib-1.2.11.tar.gz$ tar -zxf zlib-1.2.11.tar.gz$ cd zlib-1.2.11$ ./configure$ make$ sudo make install OpenSSL 库 – NGINX SSL 模块依赖，用来支持 HTTPS： 123456$ wget http://www.openssl.org/source/openssl-1.0.2f.tar.gz$ tar -zxf openssl-1.0.2f.tar.gz$ cd openssl-1.0.2f$ ./configure darwin64-x86_64-cc --prefix=/usr$ make$ sudo make install 下载源码从这里找到需要下载的最新版：http://www.nginx.org/en/download.html 123$ wget http://nginx.org/download/nginx-1.12.0.tar.gz$ tar zxf nginx-1.12.0.tar.gz$ cd nginx-1.12.0 基本配置： 123456$ ./configure--with-pcre=../pcre-8.40--with-zlib=../zlib-1.2.11--with-http_ssl_module--with-http_v2_module--with-stream 编译安装： 12$ make$ sudo make install 运行（debian 下的默认路径）： 1$ sudo /usr/local/nginx/sbin/nginx 配置到 systemd添加文件/lib/systemd/system/nginx.service内容如下： 123456789101112131415[Unit]Description=The NGINX HTTP and reverse proxy serverAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -tExecStart=/usr/local/nginx/sbin/nginxExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 刷新 systemd 服务： 1systemctl daemon-reload 启用服务： 1systemctl enable nginx 使用 systemd 启动 nginx： 1systemctl start nginx 查看 nginx 服务状态： 1systemctl status nginx 正常运行的状态如下： 12345678910111213● nginx.service - The NGINX HTTP and reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled) Active: active (running) since Thu 2017-06-15 14:55:09 CST; 16min ago Process: 9452 ExecStart=/usr/local/nginx/sbin/nginx (code=exited, status=0/SUCCESS) Process: 9449 ExecStartPre=/usr/local/nginx/sbin/nginx -t (code=exited, status=0/SUCCESS) Main PID: 9453 (nginx) CGroup: /system.slice/nginx.service ├─9453 nginx: master process /usr/local/nginx/sbin/nginx └─9454 nginx: worker processJun 15 14:55:09 rasp nginx[9449]: nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is okJun 15 14:55:09 rasp nginx[9449]: nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successfulJun 15 14:55:09 rasp systemd[1]: Started The NGINX HTTP and reverse proxy server. HTTP2 配置只需要 server 下的 listen 属性后添加 http2 即可： 1234...server { listen 443 ssl http2;... TCP/UDP 负载均衡其实这个对我没鸟用，本来希望像反代 HTTP 服务那样反代一个 MySQL 服务到一个二级域名，结果在 server 下配置 server_name 属性提示不合法。查了一下 nginx 配置域名代理的前提是 http 请求中携带了需要请求的域名信息 nginx 才能负责分发，而 TCP/UDP 的网络连接就不能使用这个特性了。 也把配置写下吧，不过单台机器上的作用和端口转发基本一样了，不是很有必要： 123456789101112stream { upstream mysql { hash $remote_addr consistent; server 0.0.0.0:33060 max_fails=3 fail_timeout=30s; } server { listen 3306; proxy_connect_timeout 30s; proxy_timeout 600s; proxy_pass mysql; }} 参考资料：https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/","link":"/2017/06/15/install-nginx-by-source/"},{"title":"Java 中实例化一个抽象类对象的方式","text":"在 Java 中抽象类是不能直接被实例化的。但是很多时候抽象类的该特点成为一个比较麻烦的阻碍。例如如果我想使用动态代理来给一个抽象类赋予其执行抽象方法的能力，就会有两个困难：1. 动态代理只能创建实现接口的一个代理对象，而不能是一个继承抽象类的对象。为此标准的 JVM 中有一些实现，例如 javassist 可以使用字节码工具来完成这一目的(ProxyFactory)。 在 Android 中如果想构造一个抽象类对象，恐怕只有 new ClassName() {} 或者继承之后构造了。但是这两种方法都是不能由其 Class 对象直接操作的，这就导致一些问题上达不到我们需要的抽象能力。这里详细描述一下第一段所说的场景： 首先有一个 interface 文件定义如下（熟悉 Android 的朋友可以看出这是一个提供给 Retrofit 生成代理对象的 Api 配置接口）： 123456789101112public interface RealApi { @GET(\"api1\") Observable&lt;String&gt; api1(); @GET(\"api2\") Observable&lt;String&gt; api2(); @GET(\"api3\") Observable&lt;String&gt; api3(); //...其他方法} 其次再写一个抽象类，只实现接口的其中一个方法（用来模拟接口数据）： 123456@MockApipublic abstract class MockApi implements RealApi { Observable&lt;String&gt; api3() { return Observable.just(\"mock data\"); }} 然后我们需要有一个工具，例如 MockManager ，让他结合我们已存在的 RealApi 对象和 MockApi 类，来构造出一个混合对象，该对象在执行 MockApi 中已经定义的方法时，为直接执行，在 MockApi 没有定义该方法时，去调用 RealApi 的方法。其调用方式大概为： 1RealApi api = MockManager.build(realApi, MockApi.class); 通过 javassist，完成上述功能很简单，创建一个 ProxyFactory 对象，设置其 Superclass 为MockApi，然后过滤抽象方法，设置 method handler 调用 realApi 对象的同名同参方法。这里就不再给出代码实现。 但是在 Android 上，javassist 的该方法会抛出1234Caused by: java.lang.UnsupportedOperationException: can&apos;t load this type of class file at java.lang.ClassLoader.defineClass(ClassLoader.java:520) at java.lang.reflect.Method.invoke(Native Method) at javassist.util.proxy.FactoryHelper.toClass2(FactoryHelper.java:182) 类似的异常。原因大概是 Android 上的虚拟机的实现和标准略微不同，所以这里把方向转为了动态代码生成的另一个方向 Annotation Processor。 使用 Annotation Processor 实现的话，思路就简单的多了，但过程还是有些曲折： 首先定义一个注解，用来标记需要构造对象的抽象类 12345@Target(ElementType.TYPE)@Documented@Retention(RetentionPolicy.SOURCE)public @interface MockApi {} Processor 根据注解来获得类的 element 对象，该对象是一个类似 class 的对象。因为在预编译阶段，class 尚未存在，此时使用 Class.forName 是不可以获取运行时需要的 Class 对象的，但是 Element 提供了类似 Class 反射相关的方法，也有 TypeElement、ExecutableElement 等区分。使用 Element 对象分析注解的抽象类的抽象方法有哪些，生成一个继承该类的实现类（非抽象），并在该类中实现所有抽象方法，因为不会实际用到这些抽象方法，所以只需要能编译通过就可以了，我选择的方式是每个方法体都抛出一个异常，提示该方法为抽象方法不能直接调用。生成代码的方法可以使用一些工具来简化工作，例如 AutoProcessor 和 JavaPoet，具体实现参考文尾的项目代码，生成后的代码大致像这样： 123456789101112// 生成的类名使用原类名+\"$Impl\"的后缀来命名，避免和其他类名冲突，后面也使用该约束进行反射来调用该类public final class MockApi$Impl extends MockApi { @Override public Observable&lt;String&gt; api1() { throw new IllegalStateException(\"api1() is an abstract method!\"); } @Override public Observable&lt;String&gt; api2() { throw new IllegalStateException(\"api2() is an abstract method!\"); }} 根据该抽象类的类名去反射获得该实现类，然后再根据反射调用其构造方法构造出一个实现对象。 12345678// 获得生成代码构造的对象private static &lt;T&gt; T getImplObject(Class&lt;T&gt; cls) { try { return (T) Class.forName(cls.getName() + \"$Impl\").newInstance(); } catch (Exception e) { return null; }} 构造一个动态代理，传入 RealApi 的真实对象，和上一步构造出的抽象类的实现对象，根据抽象类中的定义来判断由哪个对象代理其方法行为：如果抽象类中有定义，即该方法不是抽象方法，则抽象类的实现对象执行；反之，由接口的真实对象执行。 12345678910111213141516171819202122232425262728293031public static &lt;Origin, Mock extends Origin&gt; Origin build(final Origin origin, final Class&lt;Mock&gt; mockClass) { // 如果 Mock Class 标记为关闭，则直接返回真实接口对象 if (!isEnable(mockClass)) { return origin; } final Mock mockObject = getImplObject(mockClass); Class&lt;?&gt; originClass = origin.getClass().getInterfaces()[0]; return (Origin) Proxy.newProxyInstance(originClass.getClassLoader(), new Class[]{originClass}, new InvocationHandler() { @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable { // 获取定义的抽象类中的同名方法，判断是否已经实现 Method mockMethod = null; try { mockMethod = mockClass.getDeclaredMethod(method.getName(), method.getParameterTypes()); } catch (NoSuchMethodException ignored) { } if (mockMethod == null || Modifier.isAbstract(mockMethod.getModifiers())) { return method.invoke(origin, objects); } else { return mockMethod.invoke(mockObject, objects); } } });} 完成上述工作以后，就可以像开头所说的那样，使用 build 方法来构造一个混合了真实接口和抽象类方法的代理对象了，虽然调用的类本质上还是硬编码，但是由 Annotation Processor 自动生成免于手动维护，使用上来讲和使用 Javassist 实现还是基本相同的。 我用本文中所属的方法实现了一个模拟 retrofit 请求的工具（文尾有链接），但本质上可以用它来实现很多需要构造抽象类的需求，更多的使用场景还有待挖掘。 文中提到的源码实现可以在项目 retrofit-mock-result 中找到； 因作者技术能力有限，可能有更好的实现方式也欢迎指正","link":"/2017/04/07/instantiating-an-abstract-class-in-java/"},{"title":"iPod touch 6","text":"最近买了 iPod touch 6，这是我继四代和五代之后买的第三款 iPod touch 了。 说起买 iPod touch，很多人理解这个产品的定位——确实，苹果现在连自己都不怎么看重这个产品，从官方首页的导航栏中撤除就可以看出这一点。但是对于我来说，它仍然是一个再合适不过的电子产品。 我有一个老款的 MacBook Pro（Early 2011），一个 Nexus 7 2013，还有小米4。首先我是一个 Android 爱好者，手机上我有很多事情是 iOS 不能完成或者不能方便的完成的，比如网络代理，短信转发，还有就是我是一个 Android 开发者，现在对 Android 更有兴趣，所以我不会把 iPhone 作为主力机。然后平常我也会用 Nexus 看一些电子书、视频或者使用一些泛阅读类应用比如稍后阅读（Pocket）。MacBook 不用说了，主力设备加生产力工具，虽然是老款的乞丐版，在加过 SSD 做成 FusionDrive 后 I/O 瓶颈也解决不少，除了显卡有些力不从心外一切都很顺手。 有了这些之后，我仍有一些需求没有被满足。我偶尔玩一下炉石，但是炉石这种游戏在电脑上完似乎有点小题大做，我需要一个便携的游戏设备；我喜欢听播客，手机在户外时显然电量是个短板，同理还有拍照录音等场景。 所以我需要一个 iPod touch。第六代外观和上一代没有多大变化，去掉了我之前就没用过的 loop 口（挂腕带的），性能的提升还是蛮大的。我可以在上面体验到所有 iPhone 生态圈的 App，并且它更轻巧便携便宜。我想 iPod touch 这个系列我或许会买到知道它死掉了 XD。","link":"/2015/09/20/ipod-touch-6/"},{"title":"搭建 jenkins 构建 Android 项目","text":"之前用过 Flow.ci、Travis 等公共的 CI 工具感觉很方便，但毕竟源码在别人那里多少有点别扭。Jenkins 是一个免费的高度可定制的 CI 开源项目，现在的公司使用它来构建 Android 项目，所以也来试一试，记录下搭建的过程以及遇到的问题，供自己和需要的人参考。 安装 Docker因为不喜欢直接装在本地环境（hard to uninstall），并且看到 Jenkins 提供了官方的 Docker 版本，于是选择了 Docker for Mac， 地址是 https://docs.docker.com/docker-for-mac/ 虽然还是 Beta 版，但是感觉比之前 vbox 版好用一些。 使用 Jenkins 官方的 Docker 镜像安装好之后，可以执行 docker 命令查看环境是否被正确安装。正常情况下会输出 docker help。直接在 LaunchPad 中启动 Docker 的 App 后，就可以拉取官方的镜像了，在终端输入： docker pull jenkinsci/jenkins 然后创建并运行一个 container： docker run -p 8080:8080 -p 50000:50000 jenkins 之后会输出创建和初始化的日志，然后在 localhost:8080 即可打开网页进行初始化的一些配置、插件安装等。刚进入 Web 的时候，留意一下要用到一个密码，这个密码会在终端输出。 配置好 Ctrl-C 就可以停止掉这个 Container，之后启动和停止就可以使用 docker start [container id] 和 docker stop [container id] 来操作，查看 container id 使用 docker ps -a。后面需要进入到 container 中来配置某些东西时可以使用 docker exec -i -t [container id] bash 来进入到 container 的 shell 环境中，如果需要 root 身份则使用 docker exec -i -t -u root 。 安装 Plugins包括 Gradle、Git 等常用的，有一些是必装的，如果你不清楚装哪些插件，可以先查一下或者直接安装官方默认推荐的插件。我是直接安装官方的，可以满足 Android 构建的需求。 配置 Android SDK使用上面提到的方法进入 jenkins container 的 shell 中，下载 Google 官方的 Android SDK。因为 Docker 的系统层用了 ubuntu 所以选择 Linux 版的 SDK，使用 wget 下载。 12345678910# 下载wget http://dl.google.com/android/android-sdk_[version name]-linux.tgz# 解压tar zxvf [下载后的文件]# 删除压缩包rm [下载后的文件]# 运行非图形化界面，查看可下载的组件(和 UI 里查看并勾选的那个列表是相同的功能)android list sdk --all# 记下需要安装的组件编号(前面的数字)，执行下面的命令下载安装android update sdk -u --all --filter &lt;number&gt; 主要需要的组件包括 Platform Tools, Build Tools, Android Support 库，我这边查到的编号是 7、30 和 143。 然后需要在 Jenkins 中配置 ANDROID_HOME 这个环境变量，指向你放置 SDK 的根目录 安装完之后，在构建时可能会遇到：“aapt” IOException error=2, No such file or directory” 还需要两个系统组件需要在 root 账户下使用 apt-get 安装，否则在使用 aapt 工具时会报错： apt-get install lib32stdc++6 lib32z1 创建项目之后就可以创建一个 Android 项目来构建了。创建的过程资料就很多的，可以根据自己需要添加源码拉取的方法、构建的步骤、构建完的操作，定制化非常高。这边有时间再详细补充一下吧(可能永远没时间) 关于最佳实践关于 docker 的使用，自己之前一直的一个误区就是把 docker 当成了 server 来用（其实主要是懒和对 docker 的使用不熟悉）。实际上 docker 实践中 container 是用完即弃的，所以像自己之前把 Android SDK 安装在 container 中劣势就比较明显了。正确的做法应该是通过 -v 参数把 Android SDK 映射到 docker 容器中的一个文件路径中，并且把 jenkins_home 也映射到一个物理路径。这样升级 jenkins 只需要修改 Dockerfile 的一个参数重新 run 出来一个 container 就可以了，Android 的 SDK 和 jenkins 的构建数据都能得以保留。后面再专门写一篇文章来记录下这个过程吧（填小坑挖大坑 🙄）。（更新于 2016-11-22） 参考资料 How To Build Android Apps with Jenkins https://www.digitalocean.com/community/tutorials/how-to-build-android-apps-with-jenkins","link":"/2016/07/27/jenkins-android-setup/"},{"title":"Jenkins 获得本次构建的 git change log","text":"Jenkins 每次构建都会根据 git 的提交记录生成一个 web 页面来显示自上次构建之后的提交记录列表。在配置 CI 工作流时，很多情况需要获取这个提交记录的 String 值，但是 Jenkins 并没有提供这个功能。 Jenkins 官方反馈中有人也提出了这一需求：https://issues.jenkins-ci.org/browse/JENKINS-12032 。下面有人给出了一个插件来解决，插件地址：https://github.com/daniel-beck/changelog-environment-plugin ，不过作者没有编译上传到 jenkins 的插件中心，也没有文档说明怎么使用，这里简单介绍一下。 首先项目拉到本地，在项目根目录执行 mvn verify 就可以编译生成我们需要的 hpi 插件文件了（编译需要很多依赖，第一次可能会比较漫长）。之后在 Jenkins 中管理插件的高级(Advanced)中，选择上传 hpi 文件，就可以安装成功了。你也可以直接下载我编译好的点击下载。 安装成功以后，在项目配置的 Build Environment 环节，会多出一个选项：Add Changelog Information to Environment。下面有三个编辑框，分别是：Entry Format、File Item Format 和 Date Format。第一个就是填写提交日志输出格式的地方，采用的是 Java String.format 占位符的形式。其中可以使用四个参数，分别是： 提交的作者 提交的 ID 提交信息 提交时间(通过 Date Format 控制格式) 例如，我在 Entry Format 输入 %3$s (at %4$s via %1$s)\\n，然后有一条在 2017-02-10 的提交记录，提交信息为「fix bug」，提交者为 twiceYuan，那么输出到环境变量的字符串就是 “fix bug (at 2017-02-10 via twiceYuan)\\n” (后面的 \\n 是为了多层转义，视使用情况请自行调整)，同样时间格式编辑框填写的是：yyyy-MM-dd。 通过设置之后，在构建时就可以通过 shell 中来获得 SCM_CHANGELOG 变量来取到更新日志了。比如自动上传更新信息到内测平台。","link":"/2017/02/21/jenkins-changelog/"},{"title":"开启用户鉴权时 Jenkins 触发远程构建时的 403 问题","text":"在开启用户鉴权后使用 GitLab 的 WebHook 来触发 Jenkins 构建时，test 请求就会提示 403 鉴权错误，网上搜索了一波资料，大多都是提示修改一些安全设置或者开启匿名用户的 job read 权限。开启 job 的 read 权限后副作用是任何人都可以查看你在 jenkins server 上的构建任务，这对于位于公网上的 jenkins 实例无疑是不安全的，最后发现最佳的实践方式是通过 Jenkins 的 token 来完成鉴权并向 trigger 的 url 发送请求。步骤如下： 首先获取 Jenkins 用户的 Application ID 和 token。使用一个有效账户登录 Jenkins，然后在左侧边栏中进入 People，选择自己的账户，再点击右侧 Configure，在右部面板找到 API Token 这一栏，点击 Show API Token 即可查看当前用户的 Application ID 和 Token，同时也可以在这里重置 Token。 获取请求地址，在 Job 的 configure 界面，勾选 Build Triggers 下的 Trigger builds remotely，token 自己填写一个，然后得到地址 JENKINS_URL/job/JOB_NAME/build?token=TOKEN_NAME 或者 /buildWithParameters?token=TOKEN_NAME 在需要继承系统的 WebHook 中填写该 URL，在 host 前面加上 [Application ID]:[Token]@，比如 https://myid:mytoken@myjenkins.com/job/myJobName/build?token=my_job_token 。","link":"/2018/08/01/jenkins-trigger-remotely/"},{"title":"JetBrains 家应用字体渲染问题","text":"昨天安装了新的系统 El Capitan，升级后发现 Android Studio 中字体很虚，但是其他应用又没有问题，在 v2ex 上提问后有人说 java 环境问题：因为 JetBrains 的 IDE 基本都是用 Java 开发的（包括 Intellij IDEA、php Storm、Android Studio 等），使用苹果提供的 java 环境里有针对系统的字体渲染，而使用 oracle 提供的 jre 就没有。所以同样有字体发虚问题的朋友请到 Apple 官网下载 java 环境即可（R 屏可无视）","link":"/2015/10/02/jetbrains-font-render/"},{"title":"JitPack 发布包含 Annotation Processor 的项目","text":"普通的项目（单个 Library Module）发布到 JitPack，体验不错几乎是零配置的。尝试了一下直接构建了一下一个包含两个 module 的项目——一个 Android Library Module 和一个纯 Java Module 的时候，JitPack 只构建了 Java 的 Module。想起之前使用 Travis 和 GitLab Pipeline 的经历，猜测这种情况需要某些配置才行。看了下官方文档果不其然，确实有针对 Android 项目的配置（https://github.com/jitpack/jitpack.io/blob/master/ANDROID.md ），其实是 3.0 以上的 gradle 才需要的，可能暂时没有适配： 项目根目录 build.gradle: 12345buildscript { dependencies { classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5' // 加上这行 }} library/build.gradle 添加:12apply plugin: &apos;com.github.dcendents.android-maven&apos; group=&apos;com.github.YourUsername&apos; 然后创建 release tag 或者根据 commit hash 开始构建就可以了","link":"/2017/03/24/jitpack-publish-project-include-annotation-processor/"},{"title":"Kotlin 的泛型系统","text":"泛型是静态类型语言中不可缺少的一部分，Kotlin 的泛型定义和使用都类似 Java，但也有一些基于工程实践考虑的优化和改进。 实化泛型参数在 Java 中经常会定义这种方法： 123&lt;T&gt; void someFunction(Class&lt;T&gt; clazz) { //...} 这是因为 Java 的泛型擦除机制无法使用形如 T.class 来获取泛型的真实类型对象。但是在调用者看来，泛型却是实实在在的固定类型，所以这里借助 Kotlin 的内联函数 inline 可以实化泛型参数，在 Kotlin 中只需要这样： 123fun &lt;T&gt; someFunction() { val clazz = T::class.java } 泛型的协变、逆变在 Java 中，定义带泛型的参数时为了更好的匹配目标类型，有 ? extends Type 和 ? super Type 两种形式，以 List 接口中的定义为例： 12boolean addAll(Collection&lt;? extends E&gt; c);void sort(Comparator&lt;? super E&gt; c); addAll 方法中，Collection 中的泛型被定义成接收类型参数 E 的子类，这是因为需要读取也就 c 的值，所以需要保证 c 是 Collection&lt;E&gt; 的子类；而 sort 方法中，则是需要类中的类型参数 E 能够被 Comparator 中的方法传入，所以也就需要保证 E 是 Comparator 类型参数的子类。 而 Kotlin 中，针对于这两种情况给了另外两个关键字：需要读取带泛型对象的值时，使用 out 来标记类型参数；需要传入类型参数的类型作为形参时，使用 in。 这两种关键字的命名的方向是不同的：Java 偏向于从原理的方向命名，而 Kotlin 的命名对于具体的使用场景更为直观。在 Kotlin 中，被 out 标记类型参数的类型称之为协变类型，它代表当 A 是 B 的子类时，C&lt;A&gt; 也能作为 C&lt;B&gt; 的子类使用；而被 in 标记类型参数的类型则相反，它代表当 A 是 B的子类时，C&lt;B&gt; 是 C&lt;A&gt; 的子类。 从方法参数的使用上来说，Kotlin 和 Java 似乎没有什么不同，而不同的地方在于 Kotlin 可以将这种定义作用在类型定义上，官方称之为声明点变型；与之相对应的，像 Java 这种在方法参数上定义的被称为使用点变型。 声明点变型在类型的声明时定义了该类型参数是用在入参还是出参上，之后在这个类中所有用到的地方都会直接调用该类型的定义名称来使用该类型的协变或者逆变。而 Java 中需要在每次使用时来重复说明该处需要协变还是逆变。Kotlin 也可以进行使用点变型，只要和 Java 一样，在声明处不进行说明，而只在使用时声明就可以了。 「*」投影因为 Kotlin 源码中不允许忽略泛型参数，所以在一些泛型不重要的地方，就不可避免的使用 * 来表示。当使用 * 时，为了保证类型安全，官方建议的模式是将泛型定义为 * 的对象封装起来，写操作一般是安全的，因为 * 可以接收一切类型；对于读操作可以进行安全的转换，对于不匹配的类型进行统一处理。","link":"/2017/12/12/kotlin-generic-type/"},{"title":"Linux系统应用与开发01","text":"老师上课给的脑图：","link":"/2013/02/27/linux01/"},{"title":"Linux系统应用与开发02","text":"#上机实验二 ###在 Linux 下完成常见任务 ###【实验目的】通过在 Linux 系统环境中完成常见的操作任务,熟悉 Linux 系统的基本用法。 ###【实验内容】 系统的登录、注销、关机与重启 Linux 图形界面基本应用 Linux 系统基本命令及其应用 Linux 系统环境中基本的文件与目录操作 Linux 系统文件权限设置 Linux 系统中的文件链接及其应用###【实验步骤】 登录系统(普通用户)。 分别应用 man、info 查看常用的 ls、ifconfig 命令的用法,熟悉 man、info的用法。 (教材第 74 页第 8 题)将主目录下的.bashrc 文件复制到/tmp 下,并重命名为 bashrc,用命令实现上述过程。 在主目录下创建一个名为 wang 的目录,并在该目录中用 touch test.txt创建一个文本文件。 (教材第 75 页第 9 题)将主目录中的 wang 目录做归档压缩,压缩后生成 wang.tar.gz 文件,并将此文件保存到/home 目录下,用命令实现上述过程。 (教材第 75 页第 14 题)在用户主目录下新建目录 software,并将路径/etc 下所有以 h 开头的文件及目录复制到 software 中,用命令实现上述过程。 (教材第 75 页第 13 题)在根目录下创建目录 gdc,并设置权限为 gdc的文件主具有读写执行权限,与文件主同组用户可读写,其他任何用户则只能读。 在主目录下的 wang 目录中分别创建一个到第 7 题所建 software 目录的 硬链接与符号链接,分别命令为 software_h 和 software_s,然后用 ls -l 查看两个链接的属性,熟悉相关含义。###【实验时间】2 学时","link":"/2013/03/05/linux02/"},{"title":"Linux中的硬链接和软链接（符号链接）","text":"用touch在主目录创建一个名为sharefile的文件：touch sharefile在主目录中分别创建到sharefile的硬链接和符号连接，名称分别为sharefile_h,sharefile_s 用ls -il查看sharefile、sharefile_h、sharefile_s的属性，了解硬链接与符号链接的差别","link":"/2013/03/06/linux03/"},{"title":"lsof命令","text":"以前有从不关机的习惯的（qiang）时（po）候（zheng），总苦恼一件事，就是删除一些应用之后，清空废纸篓总是遇到无法清空正在运行的问题。 后来发现这个问题在终端下使用 remove 命令并没有。但感觉有些别扭（主要是没有刷一下的那个音效。。。）。今天发现了 lsof 这个命令，可以根据文件来查找正在使用这个文件的进程，然后就使用 kill 命令做掉它成功清空回收站了。 另外推荐使用的 Mac 的同学一本书：《MacTalk 人生元编程》，电子版多看上有售。 （注：lsof = “list open files”（列出打开的文件））","link":"/2014/05/11/lsof命令/"},{"title":"MongoDB 学习笔记1 —— 配置与启动","text":"（环境：OS X Yosemite beta） 先将官网下载的包解压，放入自定义位置。 这里我放置到用户目录的 Library 下，完整路径 /Users/twiceyuan/Library/MongoDB/ 里面，并建立一个 lasted 文件夹链接到 MongoDB 的 HOME 文件夹，以便以后版本更新。 ###OS X 下添加到环境变量： 编辑 home 文件夹下 .bash_profile 文件，添加一下语句export PATH=&quot;/Users/twiceyuan/Library/MongoDB/lasted/bin/:$PATH&quot; ###前台启动服务： mongod --dbpath ~/Library/MongoDB/lasted/data/db/ 启动服务后即可看到运行日志来对数据库的运行进行监控 ###后台启动服务 mongod --dbpath ~/Library/MongoDB/lasted/data/db/ --fork --logpath ~/Library/MongoDB/lasted/data/log/mongodb.log 后台启动需要添加 –fork 参数。同时需要通过–logpath 指定日志的输出文件 ###Web 服务启动 如果想要在浏览器中使用图形界面来管理数据库，可以在启动命令后添加--httpinterface ###进入 MongoDB Shell： 在终端中输入mongo localhost:27017/admin后出现以下提示符则表示已经进入到 MongoDB 的 Shell 环境中了。 MongoDB shell version: 2.6.4 connecting to: localhost:27017/admin ###终止服务 如果是前台运行的话，在 OS X 的终端下直接 Control + C 就可以终止服务了。如果是后台启动，可以在 Shell 下输入 db.shutdownServer() 来终止","link":"/2014/10/01/mongodb1/"},{"title":"MongoDB 学习笔记2 —— 数据库的基本操作","text":"###增 db.db_name.insert(Object); ###删 db.db_name.remove([{key,value}]); ###查 db.db_name.find([{key:value}]); db.db_name.findOne([{key:value}]); ###改 1. 使用 update 直接更新文档获取文档： newObject=db.db_name({key:value}); 修改文档： newObject.key=new_value 更新到数据库：​ db.db_name.update({key:value},newObject) 2. 利用修改器更新(1) $inc 自增修改器 属性增加指定数值 db.db_name.update(key:value,{&quot;$inc&quot;:1}) (2) $set 修改器 属性修改为指定值。如该属性不存在，则创建并赋值 db.dbname.update(key:value,{&quot;$set&quot;,key:value}) 并且可以修改 value 的数据类型，比如集合 ​(3) $push $pop 数组 (4) $ne 和 $addToSet 对比","link":"/2014/10/01/mongodb2/"},{"title":"otto 在 Service 中发布事件","text":"otto 是 square 开发的一个 event bus 类库，项目地址：https://github.com/square/otto 在使用 otto 在 service 中发布 event 时，会抛出没有在主线程调用的异常，对于这个问题 StackOverflow 上给出解决的代码，解决思路是定义一个主线程的 handler，如果当前不在主线程，则通过这个 handler post 一个事件。代码如下： 12345678910111213141516public class MainThreadBus extends Bus { private final Handler mHandler = new Handler(Looper.getMainLooper()); @Override public void post(final Object event) { if (Looper.myLooper() == Looper.getMainLooper()) { super.post(event); } else { mHandler.post(new Runnable() { @Override public void run() { MainThreadBus.super.post(event); } }); }} 如果你恰好和我一样使用了 RxAndroid 的话，它提供了更为方便的调度器（Scheduler）来完成这个操作，我是这样实现的： 1234public static void post(final Object event) { Observable.just(event).observeOn(AndroidSchedulers.mainThread()) .subscribe(postEvent -&gt; EventBus.get().post(postEvent));}","link":"/2015/10/09/otto-在-Service-中发布事件/"},{"title":"Anko 源码阅读笔记：构建 DSL 的基本原理","text":"官方给出这一段 Anko AlertDialog DSL 的例子： 1234alert(\"Hi, I'm Roy\", \"Have you tried turning it off and on again?\") { yesButton { toast(\"Oh…\") } noButton {}} 这段代码可以构造出一个简单的对话框控件，下面介绍一下这种代码是如何被 Kotlin 解析的。 扩展函数，让函数在合适的上下文中直接调用首先 alert() 能够直接调用有可能可能：一种是它符合当时调用上下文，是当前上下文的扩展函数；一种是它被定义为全局函数，可以类似 Java 中 static import 的方式来全局调用。这里它其实是前者，我们可以查看它的定义： 1fun Context.alert(...) { ... } 说明我们是在 Context 或者其子类中调用的 alert 方法。除此之外源码中还可以看到另外两种定义： 12inline fun AnkoContext&lt;*&gt;.alert() = nullinline fun Fragment.alert() = null 第一个是在 Anko Layout 下使用时的上下文，第二个是 Fragment 下调用时匹配的函数，这两种其实本质都是在上下文中寻找合适的 context 来调用 Context 的扩展函数 alert。还有很多比如 dip，toast 都是基于 Context 的扩展函数，使用这一特性都使这些工具方法在 Kotlin 下用起来很方便。 带接收者的 Lambda 表达式在 alert {} 的 {} 内可以看到，可以直接调用 alert 相关的属性进行定义，比如 title，仿佛 title 这个属性就在当前上下文一般。如果你用过 kotlin 库函数中的 apply 和 with 可能对这种函数比较熟悉。比如 apply 的实现非常简单： 1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { block(); return this } 其中的参数 block 的类型在 Java 中不会找到类似语法，这里就是一个典型的带接收者的 lambda 表达式，它的语法是这样的： 1234567891011121314151617class Test { var name : String? = null }fun f_name(expression: Test.() -&gt; Unit) { val test = Test() // 函数接收者 expression.invoke(test) // 使用接收者调用该函数 println(test.name) // 测试是否改变接收者的属性}fun main(vararg args: String?) { f_name { // 这里可以直接或使用 this. 调用 name 属性来赋值 name = \"twiceYuan\" // 或 this.name = \"twiceYuan\" }} 这种语法可以带来这样的效果：在一个函数参数的 block 中（即被 “{“、”}” 包裹的内容），可以直接使用这个函数指定的对象的任何属性和函数，它类似于默认的 lambda 参数 it，只不过调用 it 的属性和函数时不再需要写 “it.” 来完成，而是直接使用或者用 “this.”。 这时再来看 apply 函数的实现，它展开后是这样的： 1234fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { block() return this } 这里的 block() 完全等价于 block.invoke(receiver)，而 receiver 在这里又是指向 this ，而 this 又是可以省略的。所以这里其实是相当于使用调用 apply 函数的主体，执行 apply 参数里 block 的内容，并且可以直接使用这个主体的属性和函数，这恰好就是 apply 函数的说明。 这两点就是在 Kotlin 中定义 DSL 的基本原理。","link":"/2017/12/06/read-anko-source-dsl-build-theory/"},{"title":"从 Retrofit 源码学习 Java 的动态代理的使用","text":"Retrofit 是当前 Android 最流行的 HTTP 网络库之一了，其使用方式比较特殊，是通过定义一个接口类，通过给接口中方法和方法参数添加注解的方式来定义网络请求接口。这种风格下定义一个网络接口变得很简单。不过 Retrofit 是如何使用一个接口的 Class 创建出来实现了该接口的对象呢？最近因为工作原因想封装项目中的网络请求部分，在解决获取泛型嵌套问题的时候，一直没有找到比较理想的方案，所以拜读了 Retrofit 的源码看看这个明星网络库是如何实现这一黑科技的。 Java 的动态代理机制在 Retrofit 2.0 中，create 方法中是这样定义的： 123456789101112131415public &lt;T&gt; T create(final Class&lt;T&gt; service) { Utils.validateServiceInterface(service); if (validateEagerly) { eagerlyValidateMethods(service); } return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable { //... } }); } 前两段的Utils.validateServiceInterface(service)和eagerlyValidateMethods(service)从命名可以看出是验证传入接口合法性的，所以跳过。 接下来调用了一个关键方法 Proxy.newProxyInstance()，这个方法就是创建一个代理实例的方法，该方法需要三个参数，ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h，其中 interfaces 放置了我们传入的接口 class，InvocationHandler 也是一个接口，只有一个回调方法，也回调了三个参数：Object proxy, Method method, Object… args：其中 proxy 就是构造出来的代理实例，使用 proxy 调用一个方法时，这里传进来的 mthod 就是该方法，而 args 就是这个参数。 空说无凭，使用代码测试一下： 首先假装已经有个一个 retrofit，来定义一个接口类 1234567interface Api { @POST(\"http://example.com\") CallAdapter&lt;User&gt; fetchUser(); @POST(\"http://example.com\") CallAdapter&lt;String&gt; login(@Param(\"username\") String username, @Param(\"password\") String password);} 跟真的一样。 接下来 retrofit 调用了一个 create 方法返回的 Api 对象就让它能 fetchUser，能 login 了。那么可以想象一下，如果需要实现这些事情，它需要从这个接口定义中获取什么？ 首先是 @POST，它让 retrofit 知道了这个请求是使用 post，然后里面的值是一个 PATH(这里为了实现简单直接放上了完整的路径)，通过它和构造 retrofit 对象时的 baseUrl 就得到了接口的完整 URL。再后面需要知道定义的参数，每个注解对应的是一个参数，同时注解里标注了这个参数的名字，所以这里获取的应该是所有参数注解值和参数的值。知道这些也就万事俱备了，接下来 retrofit 只要把请求构造出来交给 OkHttp 然后等待返回结果再传给返回值。 为了获得上面所说的信息，在 invoke方法里尝试以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 打印调用的请求方法 System.out.println(\"调用的请求方法：\" + method.getName()); // 这里获取了方法的注解，retrofit 就是在这里判断使用的哪种请求方式，以及获取 path POST annotation = method.getAnnotation(POST.class); String postUrl = annotation.value(); System.out.println(\"Url: \" + postUrl); // 非法判断是个麻烦的事情，这里我们只实现例子中 api 的解析，所以以下代码不进行异常判断。 if (args != null &amp;&amp; args.length != 0) { List&lt;String&gt; params = new ArrayList&lt;&gt;(); // 获取所有参数的所有注解。得到的是一个二维数组，前面一个下标代表的是第几个参数，后面下标代表的是这个参数的所有注解。这里我们每个参数只定义了一个注解，所以直接取了[0] Annotation[][] annotations = method.getParameterAnnotations(); for (int i = 0; i &lt; args.length; i++) { Annotation[] paramsAnnotation = annotations[i]; // 取到 Param 注解中的值，这个值在 retrofit 中一般是参数的键，而 args[i] 则是参数的值 params.add(String.format(\"%s: %s\", ((Param) paramsAnnotation[0]).value(), args[i].toString())); } // 打印所有参数 System.out.printf(\"Params: %s\\n\", params.toString()); } // 下面的内容可能更加关键：如何获得返回值类型。 // 我们用了默认的 CallAdapter 来实现 // 首先获得 CallAdapter 里定义的泛型，也就是我们最终需要的数据 class Type genericReturnType = method.getGenericReturnType(); // 这里获得的是最外层，也就是 CallAdapter // 这里偷懒使用了 Retrofit 工具类中的方法来获取 CallAdapter 的泛型。这边为了显示方便又强制转换成了 Class 对象，实际上例如 Gson，直接传入 Type 就可以解析出实体了不需要再转换为 Class Class resultClass = (Class) getParameterUpperBound(0, (ParameterizedType) genericReturnType); System.out.println(\"return: type\" + resultClass.getSimpleName()); // 返回调用需要的实体。这里为了篇幅没有再模拟网络请求，而只是调用了 newInstance 来创建一个对象回调出去。 return (CallAdapter&lt;T&gt;) call -&gt; { if (call != null) { try { //noinspection unchecked call.call((T) resultClass.newInstance()); } catch (InstantiationException | IllegalAccessException e) { e.printStackTrace(); } } };} 好了验证一下结果： 123456789Api print = create(Api.class);print.fetchUser().call(user -&gt; { String result = \"print.fetchUser().call =&gt; \" + user.getClass().getSimpleName(); System.out.println(result);});print.login(\"user1\", \"passw0rd\").call(s -&gt; { String result = \"print.login(\\\"user1\\\", \\\"passw0rd\\\").call =&gt; \" + s.getClass().getSimpleName(); System.out.println(result);}); 打印结果： 123456789调用请求方法：fetchUserUrl: http://example.comreturn: typeUserprint.fetchUser().call =&gt; User调用请求方法：loginUrl: http://example.comParams: [username: user1, password: passw0rd]return: typeStringprint.login(&quot;user1&quot;, &quot;passw0rd&quot;).call =&gt; String 完全符合预期。有了这些参数，Retrofit 就可以统一封装网络请求进行处理后返回给用户定义的方法了。 结语实际 Retrofit 这个模块的实现要比本文中复杂的多，不仅考虑到各个模块的解耦，对于各种请求的支持也远远超出想象。感谢 Square 提供给开源社区和 Android 这么优秀的网络库，虽然在暂时用不到它，但通过阅读源码还是能对自己有很大帮助。 (例子中的源码可以从这里获得：https://github.com/twiceyuan/DynamicProxyDemo)","link":"/2016/11/11/retrofit-dynamic-proxy/"},{"title":"Retrofit 1.9 迁移到 Retrofit 2.0","text":"retrofit 2.0 已经进入 beta2，看了泡神的文章说已基本没什么坑了，准备把自己的项目也迁移过来，发现需要改变的东西还不少，单是看依赖就多了一堆，这里把一些变动的地方整理一下。 变化Retrofitgradle compile &apos;com.squareup.retrofit:retrofit:2.0.0-beta2&apos; 还是原来的包名，final String 目前最新版本是 = “beta2”。RestAdapter 类名已不再使用，定义用 Retrofit 就可以了。 Retrofit retrofit = new Retrofit.Builder().build(); okHttp -&gt; nullOkHttpClient 已经自动被 Retrofit 依赖，不需要再单独声明。 123Retrofit retrofit = new Retrofit.Builder() .client(new OkHttpClient()) .build(); GsonConvertorgradle compile &apos;com.squareup.retrofit:converter-gson:2.0.0-beta2&apos; 123Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .build(); Log在 1.9版本里，控制日志打印只要 setLogLevel 就可以了。但是 2.0 需要在 OkHttpClient 里通过 interceptor 配置，别怕已经有现成轮子可用： gradle compile &apos;com.squareup.okhttp:logging-interceptor:2.7.0&apos; 配置（在 OkHttpClient 对象上） 1client.interceptors().add(new HttpLoggingInterceptor(new HttpLoggingInterceptor.DEFAULT)); 添加请求头方法由于retrofit 本身不再提供 interceptor 定制，这个功能也转移到了 OkHttp： 12345678910client.interceptors().add(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request newRequest = chain.request().newBuilder() .addHeader(&quot;platform&quot;, &quot;android&quot;) .addHeader(&quot;appVersion&quot;, BuildConfig.VERSION_NAME) .build(); return chain.proceed(newRequest); }}); RxJava如果想使用 rx.Observable 作为请求结果，可以配置 CallAdapter，依赖是需要添加一个依赖： gradle compile &apos;com.squareup.retrofit:adapter-rxjava:2.0.0-beta2&apos; 123Retrofit retrofit = new Retrofit.Builder() .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); 完整版本Dependenies12345678910dependenies { // ... compile 'com.squareup.retrofit:retrofit:2.0.0-beta2' // retrofit compile 'io.reactivex:rxandroid:1.1.0' // rxjava extensions compile 'com.orhanobut:logger:1.11' // print pretty Log compile 'com.google.code.gson:gson:2.5' // gson compile 'com.squareup.retrofit:converter-gson:2.0.0-beta2' // gson convertor with retrofit compile 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2' // rxjava extension with retrofit compile 'com.squareup.okhttp:logging-interceptor:2.7.0' // filter request and response log with okHttpClient} Setup Code1234567891011121314151617181920212223242526272829303132333435363738OkHttpClient client = new OkHttpClient();// set time out intervalclient.setReadTimeout(10, TimeUnit.MINUTES);client.setConnectTimeout(10, TimeUnit.MINUTES);client.setWriteTimeout(10, TimeUnit.MINUTES);// print Logclient.interceptors().add(new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() { @Override public void log(String message) { if (message.startsWith(\"{\")) { Logger.json(message); } else { Logger.i(\"Api\", message); } }}));// add custom headersclient.interceptors().add(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request newRequest = chain.request().newBuilder() .addHeader(\"platform\", \"android\") .addHeader(\"appVersion\", BuildConfig.VERSION_NAME) .build(); return chain.proceed(newRequest); }});Retrofit.Builder builder = new Retrofit.Builder() .client(client) // setup okHttp client .addConverterFactory(GsonConverterFactory.create(gson)) // GSON converter .addCallAdapterFactory(RxJavaCallAdapterFactory.create()); // RxCallAdapter// multiple serviceservice = builder.baseUrl(\"\").build().create(GistApi.class);","link":"/2015/12/26/retrofit2-0/"},{"title":"Kotlin 中的属性委托：ValueKit 的实现介绍","text":"RetroPreference 是我之前用 Java 写的一个在 Android 项目里方便使用 SharedPreferences 的小工具，它能像 Retrofit 一样定义一个方便查看和管理的接口，然后通过库提供的方法创建实现这个接口的实例来完成对 SharedPreferences 的操作。很早之前我也用 Kotlin 重写了这个工具，但是基本类型必须有一个默认值这点感觉不是很符合使用者的需求。在学习 Kotlin 的委托属性后，我意识到可以用它更简单的实现这个工具。 首先需要知道属性委托是做什么的。用过 Kotlin 的都知道，Kotlin 可以通过定义 get 和 set 的 operator 来省略 getter 和 setter 的定义(data class 可以自带这个操作符免于定义)，然后在读取该属性时只要 a.b 的形式来读、a.b = c 的形式来写就可以了。而属性委托就是可以标记这个属性的 setter 和 getter 操作由另外一个委托对象完成。这个委托对象可以接收到属性的所有者、属性的类型、名称，这基本满足了之前使用动态代理获取接口方法属性的要求，而且直接把一个存储的配置项定义为属性而不是方法显然更符合语义。所以我们希望这个工具实现后可以这样来使用（代码 1）： 12345678object Config { var username by StringValue}fun someFunction { println(Config.username) // 读取配置 Config.username = \"twiceYuan\" // 写入配置} 是不是像写变量一样简单？Kotlin 的属性委托使得这种实现成为可能。首先方便理解，需要说明上述代码中的 username 类型为 String?，StringValue 的定义中 getValue 和 setValue 中写明了这点使得它可以正确的被推测类型（代码 2）： 123456789object StringValue { operator fun &lt;T : Any&gt; getValue(t: T, property: KProperty&lt;*&gt;): String? { return read(t, property.name) as String? } operator fun &lt;T : Any&gt; setValue(t: T, property: KProperty&lt;*&gt;, newValue: String?) { write(t, property.name, newValue) }} read 和 write 方法就是读取和保存这些配置的具体实现。为了基础类型的 Nullable，这里没有把实现对应到 SharedPreferences 上，不过这与本文介绍的内容无关。 getValue 和 setValue 是一个委托对象需要实现的方法，它们接收两个参数，第一个为属性的所有者，即上述代码中的 Config 对象，第二个参数为属性信息，通过 property.name 可以获取这个属性的名称（混淆配置中记得 keep Config 所在的文件）。 定义完成后，在代码 1 的 someFunction 中就可以调用委托对象的 getter、setter 方法来操作属性了。 如果我需要保存一个 Serializable 的对象，Object I/O Stream 明显提供了这样的操作，这样该如何完成呢？设想使用时应该是这样的（代码 3）： 12345object Config { // ... // 存储一个个人信息 var person by ObjectValue&lt;Person&gt;()} 这里可以看出 ObjectValue&lt;Person&gt; 后有个 () 表示是创建一个对象，这是因为 object 单例不能生命一个带类型参数的对象（因为它是固定的）（这其实是一个优化点，因为如果项目中含有大量相同类型的 ObjectValue&lt;T&gt; 其实只需要一个即可）。 对于这种用法，只需要定义带参数的委托对象即可（代码 4）： 123456789class ObjectValue&lt;Object: Serializable&gt; { operator fun &lt;T : Any&gt; getValue(t: T, property: KProperty&lt;*&gt;): Object? { return read(t, property.name) as Object? } operator fun &lt;T : Any&gt; setValue(t: T, property: KProperty&lt;*&gt;, newValue: Object?) { write(t, property.name, newValue) }} 如果不考虑使用者的方便性，只需要一个 ObjectValue 来实现这个工具也是可行的，因为基本类型也是实现了 Serializable 的类型，可以使用相同的方法来保存读取。 以上代码均属于 ValueKit 这个小工具的实现，欢迎 review：https://github.com/twiceyuan/ValueKit","link":"/2017/12/10/rewrite-retropreference-by-kotlin/"},{"title":"博客开通 RSS 订阅","text":"安装了官方的插件，博客正式支持 RSS 订阅了","link":"/2014/05/24/rss/"},{"title":"使用 nexus 搭建 maven 私有仓库和 gradle maven 插件的配置","text":"现在在 Android 开发特别是 Android Studio 普及依赖之后，gradle 是日常需要使用的必不可少的工具之一，使用 gradle 构建 Android 项目时一个重要的功能就是管理项目的依赖。在 gradle 中配置依赖是十分方便的，一般只需要配置一个仓库的地址，例如： 123repositories { maven { url \"http://path/to/repo/\" }} 然后再根据需要依赖模块的 group + module + 版本号 就可以指定需要依赖的模块了。例如： 123dependenices { compile \"groupName:moduleName:versionName\"} 这是平常使用 gradle 进行管理依赖的方法，如何搭建一个可以像上述配置可以使用的依赖呢？上面这种配置方式其实使用的是 maven 仓库，所以按照配置 maven 仓库的方式配置就可以了。Nexus(不是 Google 亲儿子) Repository Manager 是一个专门用来搭建的私有仓库和 Maven 镜像界面的仓库管理系统，有免费版 OSS 可以使用(地址：https://www.sonatype.com/download-oss-sonatype )，官方下载解压后就可以直接运行 bin/nexus start 启动，官方也提供了 Docker 镜像来创建容器使用，依赖也比较少所以搭建相对简单，这里不再对此说明。 默认的 nexus 管理权限设置是非常不安全的，如果需要在公网中访问，建议在配置完成后首先进行如下设置： 修改 admin 密码，默认密码过于简单 禁用 anonymous 账户 创建可读的账户和可部署的账户(或者角色Role) 以上设置都在 Administration - Security 菜单下。配置可读账户和可部署账户时，是通过给 Role 分配 Privileges 来实现的，Privileges 里定义了对各个仓库的可读、可写、可删除的权限，我们简单实用的话只分配对 maven release 仓库的权限就可以了。 之后就是在 Android Studio(gradle) 中的配置。 首先给需要上传 nexus 的 module 添加 maven 插件，官方提供了可以直接引用，在 module 的 build.gradle 上添加： 1apply plugin: 'maven' 之后在最下面添加(其实位置随意)：1234567891011uploadArchives { repositories.mavenDeployer { repository(url: REPO_URL) { // 仓库地址 // 这里配置上传账户的用户名和密码 authentication(userName: REPO_USERNAME, password: REPO_PASSWORD) } pom.version = VERSION_NAME pom.groupId = GROUP_ID pom.artifactId = MODULE_ID }} 以上就是可以使用的最少配置，还有一些比如配置 license 可以在官方文档里查找属性说明。上面配置中的全大写的部分都是配置中定义的常量，推荐使用这种方式来保存这些配置。 另外，方便自己在引用时查阅源码而不是看反编译的代码，可以在打包过程中添加 javadoc 的 jar 文件和 source 的 jar 文件。这样在引用者查看所引用类库中的类时也能方便的查阅源代码和注释。 123456789101112131415161718task sourcesJar(type: Jar) { from android.sourceSets.main.java.srcDirs classifier = 'sources'}task javadoc(type: Javadoc) { failOnError false source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) classpath += configurations.compile}task javadocJar(type: Jar, dependsOn: javadoc) { classifier = 'javadoc' from javadoc.destinationDir}artifacts { archives sourcesJar archives javadocJar} 之后就可以在右侧边栏的 gradle tasks 里找到 uploadArchives 来上传 aar 到仓库了。 上传完成后可以在 nexus 中的 component 里看到上传的依赖了。因为我们私有仓库配置中禁用了匿名用户，所以直接引用时会报错找不到该依赖，所以在配置仓库地址时还需要添加上账户认证的信息： 12345678910repositories { // other repo... maven { url REPO_URL credentials { username REPO_USERNAME password REPO_PASSWORD } }} 以上就是配置的全过程，但是有一点遗憾，没有找到像 Google 的 Support Library 那样有版本更新时可以在 gradle 配置文件中提示的功能，查阅了很多资料也没找到对应的配置方法，希望有了解的朋友指教。","link":"/2016/10/29/setup-private-maven-repo-for-gradle-project/"},{"title":"升级 macOS Sierra 后 Chrome 打开 HTTPS 的网页出错的问题","text":"升级 macOS 后，Chrome 访问 HTTPS 的网页总是一闪而过一个错误，然后才会加载成功。在网上看到别人说可能和支付宝的服务有关，移除之后就正常了。移除命令： sudo launchctl remove com.alipay.DispatcherService 更彻底一些的： sudo rm -rf /Library/Application\\ Support/Alipay /Library/LaunchDaemons/com.alipay.DispatcherService.plist ~/Library/LaunchAgents/com.alipay.adaptor.plist -rf ~/Library/LaunchAgents/com.alipay.refresher.plist ~/Library/Internet\\ Plug-Ins/aliedit.plugin ~/Library/Internet\\ Plug-Ins/npalicdo.plugin","link":"/2016/09/26/sierra-chrome-bug/"},{"title":"Travis 上接受 SDK License","text":"在 Travis 上构建项目时有时会遇到自己设备构建成功了，却在 Travis 上提示某个 component 安装失败，需要接受其对应的 license。在失败时其实已经给出一个地址说明了解决方法：https://developer.android.com/studio/intro/update#download-with-gradle 简单来说就是把自己设备上的 license 允许后生成的文件拷贝到对应的 CI 机器。其实这个文件就是一个 license 的哈希值，所以直接用 echo 重定向到对应位置的文件就可以了。可以利用 before_script 来完成这部分的工作，首先查看自己设备上的 license 哈希值。 1234$ cat $ANDROID_HOME/licenses/android-sdk-licensed56f5187479451eabf01fb78af6dfcb131a6481e8933bad161af4178b1185d1a37fbf41ea5269c55% 我修改后完整的配置为： 12345before_install: - yes | sdkmanager &quot;platforms;android-28&quot; - mkdir -p &quot;$ANDROID_HOME/licenses&quot; - echo -e &quot;\\nd56f5187479451eabf01fb78af6dfcb131a6481e\\n8933bad161af4178b1185d1a37fbf41ea5269c55&quot; &gt; &quot;$ANDROID_HOME/licenses/android-sdk-license&quot; - chmod +x gradlew","link":"/2018/11/07/travis-accept-licenses/"},{"title":"用 Supervisor 监听程序运行","text":"今天发现之前搭的 nexus maven manager 服务挂了，被要求解决挂了之后不能自动重启的问题。本来想写个 shell 糊弄一下，请教了一下公司的后端小哥得知了 supervisor。其实 supervisor 之前倒也「用」过，阴影中的袜子官方文档貌似就介绍过它的使用，查了一下文档发现用起来很方便，应该是此类问题的最佳实践了，这里稍微记录一下基本用法。 安装使用 python 实现的，所以使用 pip 或者系统默认的包管理工具都可以找得到，比如pip install supervisor 或者 sudo apt-get install supervisor。 基本使用supervisord -c /path/to/configure/file.conf 可以直接根据配置文件来开启 supervisor，更方便的是使用 supervisorctl 。 使用 supervisorctl 会进入一个 shell 的交互界面，可以输入命令来完成启动，重启，查看状态等工作。比如 help。 哦对有 help，自己看 help 吧，本文介绍完毕。 参考：http://liyangliang.me/posts/2015/06/using-supervisor/","link":"/2016/11/24/supervisor-note/"},{"title":"为Hexo添加文章目录","text":"Hexo在2.4.1添加了文章目录（Table Of Contents）功能，但是一些主题里可能默认并没有集成，下午搜索学习了一下，把方法做个总结（以Landscape为例）： ##修改步骤 修改layout/_partial/article.ejs文件中，显示文章正文部分的代码： 在&lt;%- post.content %&gt;的前面，插入： 1234&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt;&lt;/div&gt; 这样做的话，新建文章的时候就可以通过指定toc为true或false来决定是否显示文章目录了。比如显示文章目录 1234title: 为Hexo添加文章目录date: 2015-01-12 21:10:31tags: [Hexo]toc: true 修改代码之后，文章目录在页面的源码中已经可以看到了，但是并没有显示出来。还需要在CSS中添加toc相关的代码，比如我是在source/css/_partial/article.styl的最后添加了以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*toc*/.toc-articlebackground #eeeeeemargin 2em 0 0 0.2empadding 1emborder-radius 5px.toc-title font-size 120%strong padding 0.3em 1ol.toc width 100% margin 1em 2em 0 0#toc line-height 1em font-size 0.8em float right .toc padding 0 li list-style-type none .toc-child padding-left 0em#toc.toc-aside display none width 13% position fixed right 2% top 320px overflow hidden line-height 1.5em font-size 1em color color-heading opacity .6 transition opacity 1s ease-out strong padding 0.3em 0 color color-font &amp;:hover transition opacity .3s ease-out opacity 1 a transition color 1s ease-out &amp;:hover color color-theme transition color .3s ease-out ##效果图 修改完成后，可以新建一个文章或者修改以前文章的toc值来看看效果。这是我修改后的效果图，为了演示，本文也象征性的进行了分段并生成了toc。","link":"/2015/01/12/为Hexo主题添加文章目录/"},{"title":"为网站配置 Safari 图标","text":"发现很多网站，比如微博、Github、知乎等，在 Safari 的书签图标都是高清无码的。而且这个和 favicon 不是同一个图片，经过搜索，这个原来是为 Safari 单独适配的。 方法很简单，把一个高清的图标放到网站根目录下，改名为：apple-touch-icon.png 就行了。","link":"/2015/04/19/为网站配置-Safari-图标/"},{"title":"使用CyanDelta自动升级失败问题","text":"from 官方FAQ ####CyanDelta failed to install a zip in recovery on my device! You probably have the official closed-source ClockworkMod recovery. It’s not supported by CyanDelta because his author has locked it to only work with his proprietary app “ROM Manager”, so we are unable to support it. If you have that recovery you can replace them with the TWRP recovery (download from here: http://teamw.in/project/twrp2 ) or a CWM-based recovery. Otherwise you can just manually install the zip files generated by CyanDelta. 原因是我使用了闭源的 ClockworkMod recovery，并不支持 CyanDelta 自动升级时需要的 「Open Recovery Script」，按照官方推荐的下载一个TWRP Recovery就可以了。","link":"/2015/01/13/使用CyanDelta升级失败问题/"},{"title":"使用 yum 处理 oracle 环境依赖","text":"安装过 oracle 的都知道，在安装之前配置环境和处理依赖是件很繁琐的事情。在 oracle 自家系统上有较好的解决方案（可能不适用于其他发行版），就是使用 yum 来安装一个预安装包来处理依赖配置环境。 方法如下： cd /etc/yum.repos.d/ wget http://public-yum.oracle.com/public-yum-ol6.repo 将 [ol6_u3_base] 和 [ol6_UEK_base] 下的 enable 参数改为1 yum install oracle-rdbms-server-11gR2-preinstall 验证环境是否正确安装，然后就可以开始运行安装程序了 详细：http://blog.csdn.net/leshami/article/details/26339933","link":"/2015/03/27/使用-yum-处理-oracle-环境依赖/"},{"title":"关于Adapter的一个异常","text":"如果你在 Android BaseAdapter 中看到了这样一个异常： java.lang.NullPointerException: Attempt to invoke virtual method &apos;int android.view.View.getImportantForAccessibility()&apos; on a null object reference 十有八九是你忘了把 getView 传递的 convertView 给 return 了。。。","link":"/2015/11/22/关于Adapter的一个异常/"},{"title":"Airmail两天体验","text":"Sparrow眼看被Google收买之后基本停止了更新，虽说官方承诺短期内会一直维护但恐怕没有大的更新了，只希望他们能做出更好的Gmail给大伙用吧:)。 其实以前用Sparrow也没有花钱买而是用的免费的广告版，以前也用过Airmail的beta版，但不知道什么原因给删掉了，但印象对它的界面和圆图标印象很深，这次看到标价￥12就毫不犹豫的买下来了。 UPDATE： 截图由于一次博客升级事故丢失了……因为找回比较麻烦，加上有些文章意义不大就不在进行修复。 见谅","link":"/2013/08/14/关于Airmail/"},{"title":"写在它的起点","text":"第一次买域名，发现自己买好都不会配置（捂脸）。 查了半天资料，Google翻译+猜，终于配置好了，看到输入域名之后进入自己的博客，兴奋。因为基本不熟悉github的使用，防止操作再把别人的东西看一遍，在这里把用到的地方记录在这里，以备查阅。 ##github绑定独立域名我用的博客系统是Octopress，CNAME文件（就是一个名为CNAME，无后缀的文件）要放在source目录下，文件内容就是你的域名（比如我的twiceyuan.info）然后到域名管理页面修改A纪录到207.97.227.245（对，github pages都要填这个），或者 CNAME 指向 username.github.com。（括号有点多，里面为自己遇到的疑惑的地方，本条除外） ##Octopress常用操作 安装主题把主题文件夹放到.theme文件夹下（*nix默认隐藏）下，然后在终端运行 rake install[‘主题文件夹名’] 添加文章 终端运行 rake new_post[‘新主题名’] 然后用任意编辑器打开编写即可，我用的是Mou，Mac下弱弱的强烈推荐，categories后面可以填写文章的标签。 发布 两步： 1.静态化rake generate 2.发布rake deploy 把源码备份到source分支 git add . git commit -m “” git push origin source 废话一篇到此结束。","link":"/2013/02/22/写在它的起点/"},{"title":"十年学会编程(作者：Peter Norvig)","text":"为何人人都这么着急？ 信步走进任何一家书店，你会看到名为《如何在7天内学会Java》的书，还有各种各样类似的书：在几天内或几小时内学会Visual Basic, Windows, Internet等等，一眼望不到尽头。我在Amazon 上做了如下的 强力检索 ：pubdate: after 1992 and title: days and (title: learn or title: teach yourself) 得到了248个结果。前78个都是计算机类书籍（第79个是 Learn Bengali in 30 days）。我用”hours”替换”days”，得到了类似的结果：更多的253书。前77本是计算机类书籍，第78本是 Teach Yourself Grammar and Style in 24 Hours。在前200本书中，有96% 是计算机类书籍。结论是：要么人们都在急急忙忙地学习计算机，要么计算机比其它任何东西都容易学。没有书籍教你在几天内学会古典音乐、量子物理，或者是养狗。 让我们分析一下，象一本名为《三天内学会Pascal》的书意味着什么： 学习： 在三天里，你没有时间写一些重大的程序，并从成功或失败中得益。你没有时间与有经验的程序员合作，并理解在那样的环境下工作是怎么回事。一句话，你不会有时间学到太多东西。因此他们只能谈论一些肤浅的东西，而不是深入的理解。正如亚力山大教皇所说，浅尝辄止是危险的事情。 Pascal： 在三天时间里，你可能学会Pascal的语法（如果你已经学过类似的语言），但你学不到更多的如何使用这些语法的知识。也就是说，假如你曾是个BASIC程序员，你可以学着用Pascal语法写出BASIC风格的程序，但你不可能了解Pascal真正的好处（和坏处）。那么关键是什么？ Alan Perlis 说过：“一种不改变你编程的思维方式的语言，不值得去学。” 一种可能的情况是：你必须学一点儿Pascal（或可能性更大的象Visual Basic 或 JavaScript之类），因为你为了完成某种特定的任务，需要与一个现存的工具建立接口。不过那不是学习如何编程，而是在学习如何完成那个任务。 三天内： 很不幸，这不够，原因由下一节告诉我们。 在十年里学会编程 研究表明 (Hayes，Bloom)在任何一种领域内，象下棋、作曲、绘画、钢琴演奏、游泳、网球、以及原子物理学和拓扑学，等等，要达到专家水平大约都要化十年时间。没有真正的捷径：即使是莫扎特，4岁时就是音乐神童，13年后才开始写出世界级的作品。在另一方面，披头士似乎在1964年的Ed Sullivan表演上一炮走红。但他们从1957年就开始表演，在获得大众青睐后，他们的第一个重大成功，Sgt. Peppers，是1967年发行的。Samuel Johnson （塞缪尔·约翰逊，英国辞典编纂家及作家）认为要花比十年更长的时间：“在任何领域中出类拔萃都要用毕生的劳作来取得；它不可能用较低的代价获得。” 而Chaucer（乔叟，英国诗人）感叹到：“人生短暂，学海无涯。” 这是我为编程成功开出的方子： 设法对编程感兴趣，并且因为它有趣而编一些程序。确保编程一直充满足够乐趣，这样你才愿意投入十年宝贵时间。 与其他程序员交流； 阅读其它程序。这比任何书本或训练课程都重要。 写程序。 最好的学习方式是 从实践中学习。 用更技术性的话说，“在一个给定的领域内，个人的最大能力不是自动地由扩展了的经验取得的，但即使是高度有经验的人也可以通过有意识的努力来提高自己的能力” (p. 366) 和 “最有效的学习需要因人而异的适当难度，目标明确的任务，丰富的信息反馈，以及重复的机会和错误修正。” (p. 20-21) 此书 Cognition in Practice: Mind，Mathematics，and Culture in Everyday Life 是阐明此观点的令人感兴趣的参考文献。 如果愿意，在大学里呆上4年或更长（在研究生院里）。你会接触到一些需要学历证明的工作，你会对此领域有更深的理解。如果你不喜欢学校，你可以（通过一些贡献）在工作中获得相似的经验。在任何情况下，光啃书本是不够的。Eric Raymond，The New Hacker’s Dictionary一书的作者，说过，“计算机科学不能把任何人变成编程专家，就象光研究刷子和颜料不会使人变成画家一样。” 我雇佣过的最好的程序员之一仅有高中程度；他做出了许多优秀的 软件，有他自己的新闻组，而且通过股票期权，他无疑比我富有的多。 和其他程序员一起做项目。在其中的一些项目中作为最好的程序员； 而在另一些项目中是最差的。当你是最好的，你能测试领导项目的能力，用你的观点激发别人。当你是最差的，你学习杰出者是怎么做的，了解他们不喜欢做什么（因为他们吩咐你做事）。 在其他程序员 之后接手项目。使自己理解别人写的程序。当程序的原作者不在的时候，研究什么需要理解并且修改它。思考如何设计你的程序以便后来者的维护。 学习至少半打的编程语言。包括一种支持类抽象的语言（象Java 或C++），一种支持函数化抽象的语言（象Lisp或ML），一种支持语法抽象的语言（象 Lisp），一种支持声明规格说明的语言（象Prolog或C++ 的模板），一种支持共行程序（coroutine）的语言（象Icon或Scheme），一种支持并行的语言（象Sisal）。 请记住“计算机科学”中有“计算机”一词。了解你的计算机要花多长时间执行一条指令，从内存中取一个字（有cache），从磁盘中读取连续的字，和在磁盘中找到新的位置。（答案） 参与一种语言标准化的工作。它可以是ANSI C++委员会，也可以是决定你周围小范围内的编程风格是应该两个还是四个空格缩进。通过任何一种方式，你了解到其他人在某种语言中的想法，他们的理解深度，甚至一些他们这样想的原因。 找到适当的理由尽快地从语言标准化的努力中脱身。明白了这些，仅从书本中你能得到多少就成了一个问题。在我第一个孩子出生前，我读了所有的（关于育儿的）How to 书籍，仍然感觉是个手足无措的新手。30个月以后，我的第二个孩子快要出生了，我回头温习这些书了吗？ 没有。相反，我依靠我的个人经验，它比专家写的数千页书更有用和可靠。 Fred Brooks在他的随笔 《没有银弹》 中定出了一个寻找优秀软件设计者的三步计划： 尽可能早地，有系统地识别顶级的设计人员。 为设计人员指派一位职业导师，负责他们技术方面的成长，仔细地为他们规划职业生涯。 为成长中的设计人员提供相互交流和学习的机会。 此计划假设某些人已经具备了杰出设计者的必要才能； 要做的只是如何恰当地诱导他们。 Alan Perlis 说得更简明扼要：“每个人都能被教会雕刻：对米开朗其罗而言，反倒是告诉他哪些事不要做。同样的道理也适用于优秀的程序员。” 所以尽管买那本Java的书吧。你可能会从中学到点儿东西。但作为一个程序员，你不会在几天内或24小时内，哪怕是几个月内改变你的人生，或你实际的水平。","link":"/2013/09/17/十年学会编程/"},{"title":"在 Mac中离线升级 Android Studio","text":"Android Studio 在线升级一直是个蛋疼问题，挂代理速度比较慢而且不稳定，但是所有蛋疼的在线升级问题都可以用一个方法解决——离线升级包。Mac 用离线升级包和Windows上基本相同只不过路径和资源的url不一样。 从http://dl.google.com/android/studio/patches/updates.xml 找最新版本号如 0.2.10 （Build number: 132.843336） 下载补丁 查找到版本号之后，直接从，http://dl.google.com/android/studio/patches/AI-[旧的版本号]-[新的版本号]-patch-mac.jar 例如从 130.737825 升级到 132.843336 就要下载 http://dl.google.com/android/studio/patches/AI-130.737825-132.843336-patch-mac.jar 下载之后可以把jar文件拷贝到 /Applications/Android Studio/ 然后终端进入到 Android Studio 目录终端输入 java -classpath XXXX.jar com.intellij.updater.Runner install . (. 不可忽略，代表当前目录) 然后会弹出一个升级框，即可完成升级。完成后即可删除jar文件","link":"/2013/09/27/在Mac中离线升级AndroidStudio/"},{"title":"在 github 上部署 maven repository 以及在 Android 中使用","text":"以 volley 为例。 首先进入项目目录，执行命令： 1mvn install:install-file -DgroupId=com.android -DartifactId=volley -Dversion=1.0 -Dfile=build/outputs/aar/volley-release.aar -Dpackaging=aar -DgeneratePom=true -DlocalRepositoryPath=repository -DcreateChecksum=true -DgroupId 选项填写应用包名-Dversion 版本号-Dfile aar文件的路径-Dpackaging 发布格式-DgeneratePom 是否生成 POM-DlocalRepositoryPath 本地库路径-DcreateChecksum 检查 MD5检验值 部署到 github 调用的时候在项目的 gradle 文件中加上下面代码就可以了 123456repositories { maven { url 'https://raw.githubusercontent.com/twiceyuan/volley/master/repository' }}dependencies { compile 'com.android:volley:1.0'}","link":"/2015/05/07/在-github-上部署-maven-repository-以及在-Android-中使用/"},{"title":"好久没更新了","text":"好像买过域名之后只活跃了一阵子 ╮(╯_╰)╭现在暂时先换上这个小帅哥的主题，原地址在这里，过两天学习学习","link":"/2013/08/02/好久没更新了/"},{"title":"在Android Studio中删除Module","text":"先前在项目设置中选择 Module 之后上面的减号不见了，所以原来删除 Module 的方法不再适用。 现在版本想要删除一个 Module（应该是0.5.2以后的版本），需要先在项目根目录下 setting.gradle 中删除所要删除 Module 的名称，然后点击工具栏上 Sync Project with Gradle Files 按钮，完成后右击所要删除的 Module 的文件夹就会发现原来不在的 Delete 键出现了，然后点击删除即可","link":"/2014/05/14/在androidstudio中删除module/"},{"title":"如何优雅地起床","text":"作者: 匿名用户 来源：如何更优雅更果断地起床？ (一个实用的生活技能，赖床困难户考虑一试。真的比各种奇葩闹钟有效而且好用多了，这样起床也不会有什么副作用，需要的 Get 一下吧)终于可以把这个贡献出来了，想优雅起床的骚年们，感谢我吧。巴甫洛夫起床法： 企图用意志力起床基本是徒劳的——早上没睡醒前总会做些错误的决定 什么自我激励、什么N个闹钟、什么会飞的会跑的会爆炸的要做题的拍照片的的懒人闹钟，都是隔靴搔痒 和学习其他技能一样，熟能生巧，训练自己，然后一切交给你的潜意识 这个方法看上去会比较白痴比较弱智，请先做好心理准备 白天清醒的时候做这个训练 尽最大可能模拟睡觉的环境：光线调暗、换上睡觉的穿着、摘掉眼镜等 闹钟调至几分钟后 躺下，用习惯的睡姿假装自己在睡觉 闹钟响起的时候，用最快的速度关掉闹铃、深呼吸、伸懒腰、坐起来、下床、换衣服 重复 每天1-2组，每组3-10次 // 就像吃药一样，每天1-2次，每次3-10粒 经过了一段时间（视每个人的情况而定）的训练，就会逐渐养成听到闹铃响就马上起床的习惯 时间越久，这个起床模式越根深蒂固 如果听到闹钟响没起床反而会觉得别扭 //就像穿裤子的时候习惯先穿左腿但是先穿了右腿一样 一旦形成了这个条件反射，就不用再进行训练了，每天的起床就是一次训练过程","link":"/2014/05/15/如何优雅地起床/"},{"title":"当我换一个新主题时","text":"Hexo 的很多特性都与主题密切相关，由于主题的高度独立性，导致使用者切换一个主题时可能要重新配置很多东西。 前段时间不小心手贱手残执行了一次 hexo init （欢迎作死尝试），结果所有配置相关的文件都被初始化了，只有一些 page 文件夹和 post 文件夹免受于害。于是所有对主题的修改和编辑都得重新弄一次（这里也由于我的疏忽大意，之前虽然有备份博客的源文件夹，不过因为阴差阳错居然 ignore 了主题文件夹，所以一切还是白搭）。 根据我的日常使用，总共有这几个部分是需要首先修改的： 有言评论插件虽然大多数人用多说，但是我感觉多说不仅样式丑，而且迁移起来难出翔，后台管理各种 bug，虽然有言也不完美，但至少界面简洁安装简单并且不用配置什么 key path 什么的，自动识别 url。关于有言的安装十分简单，只要将官方提供的一段 js 添加到 article.ejs 文件中即可。位置可参考一般主体自带的多说或者 disqus 的代码。 百度统计百度统计也好办，参考 Google 分析代码即可，一般主题都有。 微博秀添加一个文件到 widget ，代码从微博秀地址获得。 友情链接这个很简单，一般主题提供配置。不过我觉得这个是主题不想关的，完全可以放到主配置文件中。这个可以根据自己需求把 theme.links 改成 config.links fancybox由于我有在某些图片上不使用 fancybox 效果的需求，所以最好更改一下，更改方法参考以前博文：http://twiceyuan.com/2014/08/12/disable-fancybox/ 文章目录参考 http://twiceyuan.com/2015/01/12/%E4%B8%BAHexo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/","link":"/2015/04/05/当我换一个新主题时/"},{"title":"旧物新用","text":"最近校园天翼升级速度加快，导致之前一直用的基于 OpenWRT 的破解路由器废掉了。加上 Mac 上的天翼校园客户端会无端禁止系统上的代理软件，导致不能使用 shadowsocks，遂购入一台一百多的 Windows 主机倒腾网络共享，顺便也体验下家庭媒体服务器+离线下载器的功能。 买后首先要解决的问题就是没有显示器鼠标键盘的问题，所以准备以后一直使用远程连接的方式来控制，但第一次安装还是需要借来别人的显示器和键盘，然后做以下配置： 开启远程设置中的允许特定用户远程登录（也就是之后的管理员账户） 到控制面板里安全策略中允许空密码登录（关键词，空密码，远程登录） 为什么使用空密码呢？刚开始有这样的考虑：没有显示器和键盘，我必须保证开机后能自动进入系统，然后自动建立无线热点以便笔记本接入（后来用外置网卡没有尝试成功，每次开机还是有线连接了），Windows 上貌似没有 OS X 下设置用户密码，但在本机上可以开机自动登入的功能吧？所以暂时使用空密码。但是空密码也有坏处，就是所有局域网内部的人都可以远程登录到这个主机（虽然不是不信任舍友，但是把自己的硬盘暴露给所有局域网的人也多少有点不妥吧……更何况无线网也不是绝对安全的）。所以我使用了这么一个相对安全的方法：将管理员用户名后面生成一些乱码，作为显式的密码。这样未登录的用户也看到管理员的账户名，自然也不能随意登录了。 之后把自己的硬盘挂上去开启了共享，并开启流媒体相关的选项，在 OS X 连接 SMB 服务器，5G 左右的视频也能流畅播放，Perfect，也顺便解决了我对移动硬盘 NTFS 访问无力的痛。 但愿它能活久点，毕业了还能带回去孝敬长辈 ：）","link":"/2015/04/07/旧物新用/"},{"title":"更换评论系统为「有言」","text":"多说时好时断，暂时先换成有言试试~","link":"/2014/08/06/更换评论系统为「有言」/"},{"title":"经典算法合集","text":"##排序 排序算法:http://baike.baidu.com/view/297739.htm 冒泡排序法:http://baike.baidu.com/view/1313793.htm 起泡法:http://baike.baidu.com/view/174304.htm 鸡尾酒排序:http://baike.baidu.com/view/1981861.htm 桶排序:http://baike.baidu.com/view/1784217.htm计数排序:http://baike.baidu.com/view/1209480.htm 归并排序:http://baike.baidu.com/view/90797.htm 排序二叉树:http://baike.baidu.com/view/922220.html 鸽巢排序:http://baike.baidu.com/view/2020276.htm 基数排序:http://baike.baidu.com/view/1170573.htm 选择排序法:http://baike.baidu.com/view/1575807.htm 希尔排序:http://baike.baidu.com/view/178698.htm 堆排序:http://baike.baidu.com/view/157305.htm 快速排序算法:http://baike.baidu.com/view/19016.htm 插入排序法:http://baike.baidu.com/view/1443814.htm 树形选择排序:http://baike.baidu.com/view/3108940.html ##搜索 深度优先搜索:http://baike.baidu.com/view/288277.htm 宽度优先搜索:http://baike.baidu.com/view/825760.htm 启发式搜索:http://baike.baidu.com/view/1237243.htm 蚁群算法:http://baike.baidu.com/view/539346.htm 遗传算法:http://baike.baidu.com/view/45853.htm ##计算几何 凸包:http://baike.baidu.com/view/707209.html ##图论 哈夫曼编码:http://baike.baidu.com/view/95311.htm 二叉树遍历:http://baike.baidu.com/view/549587.html 最短路径:http://baike.baidu.com/view/349189.htm Dijkstra算法:http://baike.baidu.com/view/7839.htm A*算法:http://baike.baidu.com/view/7850.htm SPFA算法:http://baike.baidu.com/view/682464.html Bellman-Ford算法:http://baike.baidu.com/view/1481053.htm floyd-warshall算法:http://baike.baidu.com/view/2749461.htm Dijkstra算法:http://baike.baidu.com/view/7839.htm 最小生成树:http://baike.baidu.com/view/288214.htm Prim算法:http://baike.baidu.com/view/671819.html 网络流:http://baike.baidu.com/view/165435.html ##动态规划 动态规划:http://baike.baidu.com/view/28146.htm 哈密顿图:http://baike.baidu.com/view/143350.html 递推:http://baike.baidu.com/view/3783120.htm ##动态规划优化 优先队列:http://baike.baidu.com/view/1267829.htm 单调队列:http://baike.baidu.com/view/3771451.htm 四边形不等式:http://baike.baidu.com/view/1985058.htm ##其他 随机化算法:http://baike.baidu.com/view/1071553.htm 递归:http://baike.baidu.com/view/96473.htm 穷举搜索法:http://baike.baidu.com/view/1189634.htm 贪心算法:http://baike.baidu.com/view/112297.htm 分治法:http://baike.baidu.com/view/1583824.htm 迭代法:http://baike.baidu.com/view/649495.htm 加密算法:http://baike.baidu.com/view/155969.htm 回溯法:http://baike.baidu.com/view/45.htm 弦截法:http://baike.baidu.com/view/768310.htm 迭代法:http://baike.baidu.com/view/649495.htm 背包问题:http://baike.baidu.com/view/841810.htm http://baike.baidu.com/view/1731915.htm 八皇后问题:http://baike.baidu.com/view/698719.htm 百鸡问题:http://baike.baidu.com/view/367996.htm 二分法:http://baike.baidu.com/view/75441.htm kmp算法:http://baike.baidu.com/view/659777.html 遗传算法:http://baike.baidu.com/view/45853.htm 矩阵乘法:http://www.douban.com/group/topic/12416781/edit Floyd算法:http://baike.baidu.com/view/14495.html 路由算法:http://baike.baidu.com/view/2276401.html ICP算法:http://baike.baidu.com/view/1954001.html 约瑟夫环:http://baike.baidu.com/view/717633.htm 约瑟夫问题:http://baike.baidu.com/view/213217.htm AVL树:http://baike.baidu.com/view/414610.htm 红黑树:http://baike.baidu.com/view/133754.htm 退火算法:http://baike.baidu.com/view/335371.htm#sub335371 并查集:http://baike.baidu.com/view/521705.htm 线段树:http://baike.baidu.com/view/670683.htm 左偏树:http://baike.baidu.com/view/2918906.htm Treap:http://baike.baidu.com/view/956602.htm Trie树:http://baike.baidu.com/view/1436495.html RMQ:http://baike.baidu.com/view/1536346.htm LCA :http://baike.baidu.com/view/409050.htm 矩阵乘法:http://baike.baidu.com/view/2455255.htm 高斯消元:http://baike.baidu.com/view/33268.html 银行家算法:http://baike.baidu.com/view/93075.htm","link":"/2014/03/10/经典算法合集/"},{"title":"说说这段时间 1","text":"很久没有认真记录过东西，写了这个标题却发现以前已经有了一篇“说说这段时间”，想到以后没准会有34567，索性在后面加个2（后来心血来潮以0为起始篇，就成1了——作者20150121）。 是啊又过了那么久，曾经这个博客是为了记录自己专业学习上的成长，不知不觉半年过去了，专业学习上基本没有成长，却又走上的另外一条路。也许是对自己的专业才能不自信的缘故，本已放弃的专转本又重新拾起来，大概是因为经历了这样几件事： 苏州学习一个月之后，亲眼经历了同班同学找工作的艰难，虽然总是意识上忽略学历的重要性，但学历却又轻而易举地在应届生中拉开差距，在自己还没有真的完全蔑视学历的时候，还是提高一些比较好。 参加移动MM创业大赛之后，也见识到一些知名大学的学生实力，相信更好的大学会给自己带来更好的学习氛围。 参加蓝桥杯之后，感觉自己应该争取机会参加一些类似的更高级的比赛，比如ACM、TC等，但这些比赛的门槛就是本科。 总而言之，现在看来之前以为专科上完就工作是个幼稚的决定，但依然觉得大二一年没有考专转本也依然收获很多。除去这些比赛经验，也自学了一些东西，而不是大一的时候仅仅停留在理论。但总而言之，提高学历不是一件坏事，它能带来更多系统学习的机会，逼自己再学两年书本上的英语…… 其实前面说了这么多，也还没有说到“这段时间”这个主题。这段时间是说从上学期到学校复习专转本，到现在寒假离开学还有十来天的时间。这段时间是一个特别的时期，没有任何人安排给自己任务，只有说近不近说远不远的一个专转本摆在前面，若有若无的压力。上学期一学期的时间，真正花在复习考试的时间还是很有限的，周六周日的辅导班，隔三差五去一次的自习室，天天晚上背的单词。总算是读过了一个没有荒废也没有多少效率的学期。匆匆忙忙应付完了大一申请的Android项目，也偷闲玩起了魔兽世界，直到现在也都是说忙不忙说紧不紧的生活。早上（应该说没有早上）基本上十一二点起床，晚上，如你所见也一般都是一两点这个时间。 直到几天前做了份试卷，才知道“感觉没什么难的”高数其实大多数还是不能扔开书本做出来。别人问个题看看书上上网，没有做不出来的，但其实虚的很。前段时间也看了学霸好友的一个文章，说错题集的记法和重要性，有羞愧的想起自己从小到大从没记过一个像样的笔记，甚至自以为学的不错的专业课，其实也是零零散散，全凭现找现用。 接下来的时间里，为了不辜负自己这么多年的意淫，总要花些功夫在自己薄弱的地方，比如考试，比如英语。同时也锻炼好身体，迎接第二个大学生活。 不知道还有没有第三个。","link":"/2014/02/13/说说这段时间1/"},{"title":"说说这段时间0","text":"学校安排的实训快要结束了，这几天基本没有事情，在教室有网有空调而且没有老师，闲暇时间多出了不少。 来实训之前去北京蓝桥杯比赛，没怎么准备却捡了个“光环”，一时间有点儿腰杆儿挺直的错觉，回来之后基本属于放松状态，身边同学培训的培训，找工作的找工作，自己因为准备考专转本的缘故，每天也就是逛逛各种社交网站，补补以前落下的各种电影动画片。 前天看到知乎上来了一个小有名望的、菜鸟心目中大神级别的人物，暂且叫他A。A来了这几天畅谈了各种麻瓜听不懂的话题，也回答一些关于他传闻之类的问题。基于A的名望关注了他，每天扫几眼他的“金玉良言”。今早起来看到自己早前关注的一个程序员B（知名软件公司的不知名的人物）在一个问题中纠正了A的一堆错误，实实在在感觉到大神之上更有大神，而且程序员B一直属于很低调的、不太为人所知的一类人。 没有什么传闻，老老实实的扫地僧也许有很多，而且他们跟大师过招之后依然不为人所知。 之前买了域名折腾了好几天的博客在这几天没事干的时候又重新整理了一下。这个博客系统是个台湾的高中生写的，简洁而且高效，年龄上虽然是自己的晚辈，但却不得不让人佩服；今天又给它换了一个主题，发现也是和不大的学生制作的，好奇心驱使下又看了看作者的随笔，得知是个在读大学生，有自己的团队，做着自己的几个项目，刚参加过比赛得了几个“没想到”的奖诸如此类。但字里行间读不出任何炫耀的意思，反而充斥着对自己非常的不满。读罢不得不让人深思，自己还差的很远，不谈遥不可及的技术上的天壤之别，仅仅在态度上就已经输的很惨。 某个虽然自己不太喜欢的人说过一个自己还算赞同的话，不要停留在“一个人的状态”，看看周围的人，并不是真的只是看看自己周围区域的人，也应该主动找找自己想要做的那类人，他们在做什么。 Stay hungry, stay foolish.","link":"/2013/08/05/说说这段时间0/"},{"title":"说说这段时间 3","text":"想写第三篇随笔很久了，一直没有找到合适的时间。这段时间发生了太多事，感觉值得写一篇随笔了。首先就是专转本终于结束了，而且有了一个出乎意料的好结果——终于我在以后的简历学历上不用只写一个可怜巴巴的专科，也决定了我之后的两年又要在哪里生活。新的学校在南京，之前因为朋友@十肆先生 和比赛去过两三次，还是蛮喜欢的一个城市，至少想到之后两年在一个陌生的地方生活时，我对它的印象使我多了一份亲切感。并且可喜可贺，她也考上了南京的学校（现在还没录取……看来写的稍微有点早了些，基本也确定了吧）。 专转本的这段时间，虽说没有完全把精力耗费的数学英语计算机三门文化课上，专业技能也几乎是停步不前，接下来的暑假，是时候补一下之前欠自己的那点东西了！初步准备学习 Object-C 和 php 来进行 OS X 和微信公众平台上的开发。 Object-C 一直都有想要学的想法，先前是没有 Mac，后来有了 Mac 发现没有 iOS Device 也不是很方便，后来有了 iOS Device 发现没有闲钱买开发者证书……最后想想也许是自己一直都对不熟悉的东西有所畏惧，所以一直停步不前。清算下来，至今为止自己写的稍微算点作品的东西基本都是 Android 上的东西，是时候跳出自己的舒适区域了。不过介于依然没有打算购买开发者证书加上自己用 iOS 并不是很多，准备先从自己日常生活使用的 Mac 应用开始。php 的学习主要就是想多一个技能。专转本这段期间，好基友@lucky465 利用它找到了第一份工作并且至今以此谋生，而且他表示如果我学愿意一并做项目，是个不可多得的实践机会，而且 php 跟 O-C 相比更加平易近人，所以第二个目标就是 php，希望在未来两年，生活费可以摆脱跟家人要或者奖学金吧。 最近也知道了很多能够鼓舞自己的人，从时间上讲最近的就是 Mou 的作者罗晨。知道他是一天晚上睡觉前听 IT 公论凑巧碰到一期采访他的节目，第二天就小小八卦了一下：一名既写软件又做实物产品的全景摄影师——他在自己的淘宝店铺是这样介绍自己的。这确实不假，他创造了 Mac 上最流行的 Markdown 编辑器（我现在就在使用它），靠在 Mac 上第一个作品就已经可以维持生活，现在也已经在卖 Mou 这个项目了。他也做一些比较好玩（但死贵）的手工小玩具，我就忍不住买了一个他的热解石墨磁悬浮套件。印象最深得是 IT 公论的李如一问他做这些所有的所有的动机是，他都只有一个答案：「玩」。而且现在的他住在一个农场里，真是无比潇洒令人向往的人生玩家&amp;人生赢家。 第二个想说的人大概就是罗永浩了。他大概是我忍不住次数最多想要取消关注的微博名人之一了（之前也取关了某著名程序员），每次看他吹牛/打压竞争对手/抬杠我都多少有些不爽（而且还被抬杠了一次……），而他在几天前的发布会上着实让别人，至少是我这样只把他当个段子手的人大吃一惊。看发布会之前，我跟女朋友说，我是绝对不会买锤子的；看到一半，我跟女朋友聊天，看着不错，可以考虑；考完之后我直接说：好棒我要买！（第二天被鄙视了T_T）。不过冷静下来之后，感觉对不起自己手机的 Nexus 4 也默默放弃了预定，但罗胖子着实让我感动不已，不仅仅是 Smartisan 的每个设计细节，还有他扛得住骂的气度。虽然依然有很多人继续批评他只是营销手段而已，但他所做的事情、所付出的诚意，除了是一个成功的营销之外，也足以让更多的人受益。真心希望锤子可以成长。 回头想想自己，却又没有什么好说的了，唯有踏踏实实，继续自己的计划。眼看这个学校的任务也只剩下毕业设计和英语四级没有完成，在这个地方最后的时光里，希望可以交出一个毫不含糊的作品并得到一个令人满意的结果，也算是给三年大专生活一个完美的结束吧！","link":"/2014/05/24/说说这段时间2/"},{"title":"软件测试复习","text":"填空 软件测试按阶段划分可分为：单元测试、集成测试、系统测试、验收测试。 因果图方法是一种有效的软件测试的方法，适合于描述对于多种条件的组合、相应产生多个动作形式的测试用例设计。 面向对象是一种软件开发的思想，在整个软件生命周期都要遵循这种思想，根据软件生命周期的各个阶段，可以将面向对象测试分为：面向对象分析测试、面向对象设计测试、面向对象编程测试。 软件测试可以分为：分析学派、标准学派、质量学派、上下文驱动学派和敏捷学派。 冒烟测试是指对一个新的版本进行系统大规模的测试之前，先验证一下软件的基本功能能否实现，是否具备可测性。 软件度量是指根据一定的规则，将数字或符号赋予系统、构件、过程等实体的特定属性，从而能清晰的理解该软件实体及其属性的量化表示。 黑盒测试技术中的功能测试方法主要有：等价类划分、边界值分析方法、错误推测方法、因果图法、场景法、判定表驱动法、正交试验法、功能图法等多种。 自动化测试工具QuickTestPro进行测试的一般步骤：录制脚本，编辑脚本，执行测试，分析结果。 软件本地化是指将一个软件产品按特定国家或语言市场进行全面定制的过程，在发布时需要有针对性的进行测试。 采用Selenium IDE进行Web功能测试的一般流程：录制脚本，编辑脚本，执行测试，分析结果。 修改了旧代码以后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误，这称为回归测试。 PC-Lint是一个面向C/C++的代码静态检查工具，是一个更加严格的编译器。 CUint、CPPUnit、JUint、Visual Unit都是单元测试工具，其中CUnit测试C语言代码，CPPUnit测试C++代码，JUnit测试java代码，Visual Unit测试C/C++代码，CUnit、CPPUnit、Junit是测试框架，我们需要根据框架提供的接口编写测试程序，而Visual Unit则是一个完整的独立的测试程序。 在进行集成测试时，为了隔离单元，根据被测试单元的接口，需要开发相应的驱动程序和桩程序。 静态测试包括对产品的需求和设计规格说明书的评审、对程序代码的审查以及静态分析等。 基于模型的测试是利用模型来生成相应的测试用例，然后根据实际结构和原先预想结果的差异来测试系统。 代码评审也称代码复查，是指通过阅读代码来检查源代码与编译标准的符合性以及代码质量的活动。 白盒测试中逻辑覆盖由弱到强的6中覆盖标准是语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖。 负载压力测试时软件测试中一个重要的环节，其中 LoadRunner 是 IBM 公司著名的压力测试工具。 简答 集成测试中，根据组装模块的方式分为非渐增式和渐增式两种，渐增式又分为：自底向上和自顶向下两种方式。集成测试：每个模块完成单元测试后，需要按照设计确定的结构将它们连接起来进行集成测试也称为综合测试。 Web系统客户端兼容性测试关注的内容有：性能测试，连接测试，导航测试，界面测试，兼容性测试，帮助文档测试。 基于缺陷分析的产品质量评估方法有：经典的种子公式，基于缺陷清除率的估算方法，软件产品性能评估技术。 容错性测试的概念：容错性测试主要检查系统的容错能力，检查软件在异常条件下自身是否具有防护性的措施或者某种灾难性恢复手段。如当系统出错时，能否在指定时间间隔内修正错误并重启系统。 回归测试是在程序有修改的情况下保证原有功能正常的一种测试策略和方法，不但要检验软件所进行的修改是否正确，还要保证修改不影响原有功能的正确性。 自动化测试实现的原理：通过特定的程序模拟人员对软件系统的操作过程，首先，识别用户界面元素及捕获、键盘鼠标的输入，将操作转换为测试工具可执行的脚步，然后对脚步进行修改和优化，最后，通过测试工具运行测试脚本，将司机输出记录和预期结果进行对比分析。 软件驱动开发，全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新兴的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速开发过程。 主动测试：测试人员主动向被测试对象发送请求、或借助数据、事件驱动被测试对象的行为，从而验证被测试对象的反应或输出结果。 被动测试：软件产品运行在实际环境中，测试人员不干预产品的运行，而是被动的监控产品的运行，通过一定的被动机制来获得系统的运行数据。 软件测试和调试是两个概念，测试的目的是找出存在的错误，调试的目的是定位发现的错误并修改程序以修正错误；调试是测试之后的活动，测试和调试在目标、方法和思路上都有所不同；测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个未知的条件开始，结束的过程不可预知；测试过程可以实现设计，进度可实现确定，调试不能描述过程或持续时间。 大题目 白盒测试——逻辑覆盖法 白盒测试——基本路径测试法 黑盒测试——等价类划分法 黑盒测试——判定表法","link":"/2015/06/10/软件测试复习/"},{"title":"如何将 Intellij 项目迁移到 Gradle 项目","text":"本文来自 Google 官方文档，原文请点击 http://tools.android.com/tech-docs/new-build-system/migrating-from-intellij-projects 我们未来可能在 Android Studio 中添加一个自动迁移选项。而现在，如果要迁移一个 Intellij 项目到一个Android Gradle 项目（可以导入 Intellij 和支持直接在 Intellij 打开的），可以遵循以下步骤： 创建一个基本的「build.gradle」文件。这个文件并不像在 Android Studio 中创建项目时创建的默认 Gradle 文件，这个 gradle 文件将指向你原有的源代码文件夹（如 res/, src/）,而不是 Gradle 项目中新的目录结构（src/main/java，/src/main/res 等等）。文章下面给出一个示例 Gradle 文件。 确认你正在使用的库项目（比如 ActionBarSherlock），在 Gradle 中，你将不再需要在以源码的方式添加这些库到项目中。你可以简单的指出他们的依赖，然后系统将生成剩下的部分，下载、合并在资源和 Manifest 中的部分。对于每个库，查找相对应的 AAR 库依赖的名称（所提供的库已经被上传作为一个 Android Library Artifact），然后添加它们到依赖项中。 要找到合适的声明库列表，你可能发现这个很有用。 通过在项目中运行 gradle assembleDebug 测试编译。如果你之前 Gradle 没有进行过编译，它将从 http://www.gradle.org/downloads 安装。请注意，当你在 Android Studio 中创建新的项目时，我们会在项目的根目录创建 Gradle Wrapper 脚本（“gradlew”和“gradlew.bat”），所以任何项目中的用户都可以在您的项目中，运行“gradlew assembleDebug”等 Gradle 会自动下载安装。而已存在的 IntelliJ 项目大概不会已有 Gradle 的脚本。 注意的 IntelliJ 创建的 Android 项目一般和 Eclipse ADT 项目保持相同的结构，所以 Eclipse 的迁移指南中的说明可能也会有帮助。 build.gradle:123456789101112131415161718192021222324252627282930313233343536373839404142buildscript { repositories { mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:0.5.+' }}apply plugin: 'android'dependencies { compile fileTree(dir: 'libs', include: '*.jar')}android { compileSdkVersion 18 buildToolsVersion \"18.0.1\" sourceSets { main { manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets'] } // Move the tests to tests/java, tests/res, etc... instrumentTest.setRoot('tests') // Move the build types to build-types/&lt;type&gt; // For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ... // This moves them out of them default location under src/&lt;type&gt;/... which would // conflict with src/ being used by the main source set. // Adding new build types or product flavors should be accompanied // by a similar customization. debug.setRoot('build-types/debug') release.setRoot('build-types/release') }} 在进行过一次基础配置之后，需要获得关于这个构建系统的更多信息可以查看它的用户指南。想要获得更多信息，可以查看构建系统的概览页。 PS：本文在 2016年进行过一次更新，虽然迁移功能早已如 Google 承诺已经作为 Android Studio 的一个功能实现，但如果想要知道如何保持自己的目录结构来构建 Android 项目(有时这是有必要的，例如团队中有使用不同集成开发环境的同事)，本文仍然有参考价值。","link":"/2013/09/30/迁移到gradle项目/"},{"title":"AsyncTask简介","text":"AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute. 蹩脚翻译 仅供参考 AsyncTask 能使 UI 线程的使用变得恰当和简单。这个类允许 UI 线程在不操纵 Thread 和/或 Handler 的情况下执行后台操作和发布结果。 AsyncTask 被设计成为一个围绕 Thread 和 Handler 工作的帮助类，并且不会形成一个普通的线程框架。AsyncTask 理想中应该被用于短操作（大多是几秒）。如果你需要保持线程运行很长时间，推荐你使用 java.util.concurrent 包提供的许多类比如 Executor、ThreadPoolExecutor 和 FutureTask。 一个 AsyncTask 被定义为一个运行在后台线程并且结果公布给 UI 线程的运算。AsyncTask 定义了三个泛型：Params、Progress 和 Result 以及四个步骤：onPreExecute、doInBackground、onProgressUpdate 和 onPostExecute。 以上摘自 Google 官方文档 。 之前一直使用 Handler+Thread 来完成各种异步操作，昨天参加南京 GDG 这边组织的 Android Study Jam 介绍了一下 AsyncTask 的用法，惭愧于之前一直没有使用正确的姿势来学习 Android，养成了各种不规范的习惯。 在 AsyncTask 中，三个泛型分别代表着： Params：创建时被传入的参数 Progress：执行过程中需要及时反馈给 UI 的进度 Result：任务执行结束后的结果 四个方法分别表示： onPreExecute：执行前的准备工作。一般用于初始化 UI doInbackground：后台任务 onProgressUpdate：进度更新给 UI onPostExecute：返回结果 下面是一个小 demo 来演示一下最基础的 AsyncTask 用法： MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import android.app.Activity;import android.os.AsyncTask;import android.os.Bundle;import android.os.SystemClock;import android.widget.ProgressBar;import android.widget.TextView;public class MainActivity extends Activity { ProgressBar pb_main; TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); pb_main = (ProgressBar) findViewById(R.id.pb_main); tv_result = (TextView) findViewById(R.id.tv_main); TestTask task = new TestTask(); task.execute(); } private class TestTask extends AsyncTask&lt;Void, Integer, String&gt; { @Override protected String doInBackground(Void… params) { int progress = 0; while (progress &lt; 100) { SystemClock.sleep(100); progress++; publishProgress(progress); } return “任务完成” + progress; } @Override protected void onProgressUpdate(Integer… values) { pb_main.setProgress(values[0]); tv_result.setText(“任务进度：” + values[0] + “”); } @Override protected void onPostExecute(String s) { tv_result.setText(s); } }} activity_main.xml12345678910111213141516171819202122232425&lt;RelativeLayout xmlns:android=“http://schemas.android.com/apk/res/android&quot; xmlns:tools=“http://schemas.android.com/tools&quot; android:layout_width=“match_parent” android:layout_height=“match_parent” tools:context=“.MainActivity”&gt; &lt;TextView android:padding=“20dp” android:id=“@+id/tv_main” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:text=“@string/progress_info” android:layout_alignParentTop=“true” android:layout_centerHorizontal=“true” /&gt; &lt;ProgressBar android:id=“@+id/pb_main” style=“?android:attr/progressBarStyleHorizontal” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:layout_centerVertical=“true” android:layout_alignParentLeft=“true” android:layout_alignParentStart=“true” /&gt; &lt;/RelativeLayout&gt;","link":"/2015/04/15/AsyncTask简介/"},{"title":"大学生和职场脱节在哪里？","text":"“孩子们，欢迎从‘游乐场’模式进入到‘荒野求生’模式！”——如果在大学生眼里，即将迈入的“社会”有一扇有形大门的话，我会兴冲冲地在门上挂起这样一条横幅。游乐场模式的本质，不是它是欢乐之所，而是它是由一些既定的游玩项目——每个项目包括确定的起点、路径、终点、时程等——构成。在游乐场中，你的欢乐、兴奋、惊喜、恐惧都是可以预测的。你处于一系列虚假的挑战之中。 而在荒野求生模式中，你无所依凭。你会遭遇到一个个未曾料想的、未曾遇见的麻烦，比如饥肠辘辘、猛兽环伺，你必须使尽浑身解数，去独立地解决扑面而来的棘手问题，然后是下一个问题，又一连串问题……没有说明书、没有攻略、没有锦囊。 两种模式分别培养出不同的思维气质。 游乐场某种程度上是一种幻境，这个幻境里不需要解决现实问题。所以老师只需传授知识，你只需接受。老师们永远会这样教导你：“当你疑惑的时候，去翻教科书！去查文献！或者随时跑来问我！”这些话的潜台词是，前人已经为你预备好了答案。 所以在学校里，你思考问题时总会从理论出发：某某人在某某时间提出了某某理论，“哇，今天又学到个新知识！”；又至理论为止：通过一番思考和探究，你又验证了一遍该理论，或者（更牛一点的）对理论有新的扩展或深化，“哇，又写了篇好paper！”但是，你有没有想过，这个理论所在的领域，其最初的起源，正是为了解决某个现实的问题或者受某个真实的现象而引发。而你在接触该理论时，那个现实问题早已不存在或者不重要了；或者，它依然重要，而你却毫不关心。所以，你可能会不自觉地沿着前人铺就的道路走下去，却不知道，这条道路到底是要通向何方。 这种思维带来的一个后果是，无数学生感到迷茫：“我学的这些知识到底有什么用？！” 当然，很多过来人，包括一些教育家、科学家、哲学家，他们会语重心长地告诉你，这就是令人为之骄傲的“无用之学”，“真正高贵的知识是无用的”。而在我眼里，这些都是谎言。 任何知识，都起源于现实投射至你内心的困惑。你首先要有一个问题，这个问题困扰你、折磨你，甚至动摇你的信念、威胁你的生存。于是你必须解开它，而解决问题的过程中，就诞生了知识，包括各种概念、理论和定律。所以知识必然是有用的，它用来解决问题。在人类历史的某些时期，解决问题的需求特别强烈，于是知识的发展也就突飞猛进，比如二战——一个残酷到极致的荒野求生案例。同时，知识又必然在它所处的问题情境中才能发挥作用。 而游乐场模式，它抽离了问题情境，它只提供答案——无数过去、已解问题的答案。固然，你需要了解这些答案——这些人类文明历程中的精华。但是，你更应磨砺出“从对现实的悉心观察中挖掘问题，又对问题进行独立和系统地分析甚至构建出新的理论，以最终解决这些问题”的能力；你更应知道，当你失去了所有的拐杖和火把，当你面对一个前所未有的崭新问题，当你查了无论多少文献都找不到答案的情况下，在一片漆黑中，你如何活下去。 这就是荒野求生模式。它从观察和分析现实问题开始，经过一番（也许是理论层面上的）分析和探索，又回归到现实。 一旦进入荒野求生，你必须了解，这个世界还有一种完全不同的思维方法，只有这种方法可以帮助你很好地活下去，其要旨包括：正确地认识问题，而不是简单地使用别人的问题表述。可以基于对现实处境的深入和缜密地观察，对问题进行重新定义，以接近该问题的本质。对问题进行完全独立地思考，不借助书本和搜索引擎，因为你面前的问题是独一无二的、全新的。你可以大胆提出若干个假设性的求解方向，然后去尝试，此时失败是正常的，但你会从中得到意外的收获。继续独立地思考，但是你可以在希望比较大的求解方向下，有针对性地寻找相关联的知识，此时你需要快速筛选和学习新知识，甚至需要尽可能多地寻找各种可能有益的知识，也包括与他人交流意见。在结合知识以分析问题的过程中，你可能会试着提出一些假设性的理论或者模型。记住，不是只有专家、教授、名人、权威才有资格提出理论，你也有能力来构建理论。比如知乎上的这个答案就是从对现象的分析和洞察中独立创造理论的经典范例： http://www.zhihu.com/question/20169268/answer/14229241 。构建理论的过程可以帮助你对问题的分析达到一个新的深度，同时也能将问题简化到其最本质的层面，并且可能在将来复用至近似的问题。你提出的理论必定需要修正，这时你可以试着用你的理论去尝试解决问题，也可以试用于各种扩展情境，如果发现其bug就立即修正。迭代之后，你的理论就变得越来越有力度，解决问题的大门就此渐渐打开。但由于理论毕竟是对现实的抽象，所以你还需要去关注各种细节性的问题，去通盘考虑现实情况，去穷尽和评估各种因素，这样才能得到一个比较完备的解决方案，来彻底解决这个复杂的现实问题。通常解决一个难题的方案是非常巧妙的。如果你觉得这个方案不够巧妙，不妨试着重复以上步骤，直至找到那个巧妙的方案。 在荒野模式下，你还必须了解，与思考和发展“理论”相比，解决现实问题有如下不同之处：理论问题通常事先构想出一个理想的环境，把很多不确定的因素加以屏蔽，因此变得比较“单纯”；而对于现实问题，你必须同时考虑方方面面复杂的因素，罕有简化的方案。例如很多心理学理论，诞生于实验室的“理想环境”，因此在应用到现实时往往捉襟见肘。相反，美国商学院的研究和教学方式和传统学院派路数殊为不同，并且取得巨大的成功，究其原因，正是在于其着眼于分析复杂现实问题的理念。对这种模式优点的本质和深入的分析可参考warfalcon的这个答案： http://www.zhihu.com/question/20416520 。理论问题最初源于现实，但会渐走向自我生长的轨道，有可能随之离现实越来越远，最后变成学术圈里一小部分人的自弹自唱，与外界隔绝；而解决现实问题时，必须时刻思考人们此时此刻的真实需求是什么，为真正的价值而战。例如，大多数心理学理论已经演变为自弹自唱，不过心理学界中最有创造力的心理学家还是会从对现实的洞察中挖掘出不为人注意的新现象并为此构建理论，我相信，其它很多学科，也有类似的情况。很多学科的理论探索，通常会寻找和分析那些一般的、普遍的现象，这一方面是理论自身发展的需要，一方面也受限于科学研究对于“重复”、“可验证”的严谨性约束。但是在处理现实问题的过程中，分析极端现象的价值常常会远大于一般现象。比如塔勒布在《黑天鹅》一书就反复强调分析极端现象的重要性。而凭借需求层次理论而闻名世界的心理学家马斯洛，这个研究路数颇为另类的学者，他的另一项重要工作，是研究人类历史上最伟大人物的共同点，从而得出非常有启发性的结论，告诉我们“自我实现者”的一系列特质。在另一领域，创新设计的顶级公司IDEO十分热衷于研究“极端用户”，用以激发全新的创意，来解决异常棘手的难题。现实问题的另一个特征是，它常常瞬息万变、变幻莫测。尤其在风云变幻的商界竞争中，变化的节奏快得令人窒息。例如，前段时间京东对苏宁的电器价格战，自刘强东微博宣战不过数个小时，作为第三方的一淘网，立即上线针对性的电器比价产品，其快速响应的意识和执行力都令人瞠目。而在象牙塔中，一篇学术期刊论文的发表周期一般为两年，有些学科如数学甚至会长达五年以上（据@陈浩）；而一本更新及时的教科书，里面最新的内容，也至少是五年以前的研究，绝大多数会是十年、二十年前的结论。因此，以前作为思想和知识前沿阵地的大学，在互联网和社交媒体时代的今天，似乎已经变得过于缓慢和笨重。 简而言之，求解现实问题，就是求解复杂性，求解各种未知和不确定，以及求解永恒不息的变化。而这些，都很难在校园中得到锻炼。 大学教育的一个荒诞性在于，一方面大学生要掌握足够的本领，以进入社会、进入企业去解决全新的、复杂的现实问题；而另一方面，教育他们的大学老师们，绝大多数没有解决现实问题的经验。他们从本科到博士到讲师到教授，从未踏出校园一步；他们的知识都是自书本得来，从理论演进到理论，而丝毫不知如何从现实中学习。这种荒诞性带来的直接后果，便是学生们普遍觉得学无所用，找工作时没有竞争力，全凭着一腔热血和一股机灵来加分，而教育者，继续用前文所述的“谎言”来搪塞。 在游乐场模式中浸淫越久的人，越无法适应荒野求生模式。我在学校里多学了几年，对此感受深切，所以不得不反思起来刮骨疗伤。但是我想，很多已进入职场的人也并未意识到自己深处旧思维的牵制。举个例子来说，国内互联网业乃至一些翘楚级的公司，在他们的产品工作中，有一道重要的工序，叫竞品分析。这道工序就是抄袭的制度源头，而其背后，正是游乐场思维的结果。研究生写论文时，大多数不懂得先对该课题进行充分地、独立地思考，而是一上来就猛查一通文献，看别人用什么方法，套什么理论，自己就立即照葫芦画瓢，仿制一通；这种做法，和“通过竞品分析来拷贝抄袭别人的产品”，其背后的思维模式，丝毫没有分别。竞品就像文献，它虽给你启发，却给你无形的限制，框制住你的想象力。 所以不用奇怪，为什么在互联网行业，硅谷是无止境的创新发源地，而我国是无止境的抄袭竞速场。一个重大的原因，毫不客气地说，是从业者能力的差距；而这种差距的背后，是长期以来习得的思维模式的高下：高者直面现象、深剖问题、究其本质、创造解决方案，而低者，直接复制答案，并且囫囵吞枣、不求甚解。 或许，正是在这样的大背景下，如果你沿袭游乐场模式下的思维惯性，也许也能在职场混下去，甚至，混得还不错。但是，如果你是一个志向远大又勤勉的年轻人，如果你总是梦想着去做一些不寻常之事，或者你绝不允许自己庸庸碌碌地过完这一生，那么不妨再咀嚼一下我的答案，因为这个答案，就是为你而写的。 原文地址","link":"/2014/02/19/大学生和职场脱节在哪里？/"},{"title":"嵌入式复习","text":"嵌入式系统嵌入式系统定义嵌入式系统是以应用为中心、以计算机技术为基础、软件硬件可剪裁，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。 嵌入式系统特点上课讲：嵌入式专用、综合性强、设计高效、程序固化、需要独立的开发系统、生命周期长、可靠性高、低功效。书上：专用性、系统精简、低功耗、实时性、可靠性、技术融合、开发工具和环境。 ARM 核寄存器组31个通用寄存器和6个状态寄存器 通用寄存器 不分组寄存器R0~R7 在所有处理器模式下，它们每一个都访问的是同一个物理寄存器，是真正并且在每种状态下都统一的通用寄存器。 分组寄存器R8~R14 所对应的物理寄存器取决于当前的处理器模式R8~R12有两个分组的物理寄存器。一组用于除FIQ模式之外的所有模式，一组用于FIQ模式。R13常用作堆栈指针，称作SP。R14用作子程序链接寄存器，也称LR。在每种处理器模式下，模式自身的R14用于保存子程序返回地址。当发生异常时，该模式下对应的R14被设置为异常返回地址。 R15用作程序计数器，也称PC。由于ARM处理器采用流水线机制，当正确读取pc时，该值为当前指令地址加8字节。即pc指向当前指令的下两条指令的地址。 程序状态寄存器CPSR当前程序状态寄存器，SPSR程序状态备份寄存器。特定的异常发生时，SPSR用于保存CPSR的当前值，在异常中断程序退出时，可以用SPSR中保存的值来恢复CPSR。功能：保存ALU当前操作信息、控制允许和禁止中断、设置处理器运行模式 工作状态及运行模式两种工作状态：ARM、Thumb 七种运行模式：用户模式User、快速中断模式FIQ、外部中断模式IRQ、管理模式svc、数据访问终止模式abt、未定义指令终止模式und、系统模式sys。（除了用户模式，其他都属于特权模式） 异常响应过程1）将下一条指令的地址存入响应的异常模式的链接寄存器LR，以便程序在处理异常返回时能从正确位置重新开始执行。 2）复制CPSR寄存器的内容至对应模式下的SPSR_寄存器中。 3）对CPSR寄存器的一些控制位进行设置：无论发生异常时处理器处于Thumb状态还是ARM状态，响应异常后处理器都会切换到ARM状态，即CPSR[5]=0；将模式控制位CPSR[4:0]设置为被响应异常的模式编码；CPSR[7]=1,禁止IRQ中断；如果异常模式为复位模式或FIQ模式，则CPSR[6]=1,禁止FIQ中断。 4）将程序计数器（PC）设置为异常向量的地址，使程序从相应的异常向量地址开始执行异常处理程序。一般来说，向量地址处将包含一条指向相应异常处理程序的转移指令，从而可以跳转到相应异常处理程序处。 寻址方式立即寻址、寄存器寻址、寄存器间接寻址、寄存器移位寻址、基址加变址寻址、块拷贝寻址、堆栈寻址、相对寻址 立即寻址：MOV R1 , #0x10 ; #号开始表示立即数 寄存器寻址：MOV R1 , R2; 寄存器中的数值即为操作数 寄存器间接寻址：STR R0 , [R1];LDR R0 , [R1]; 寄存器中的数值即为操作数的地址 寄存器移位寻址：MOV R0,R1,LSL # 2; 注：LSL：逻辑左移 LSR：逻辑右移 ASL：算术左移 ASR：算术右移 ROR：循环右移 RRX：带扩展循环右移 基址加变址寻址：将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。前变址法：LDR R0,[R1,#4]; R1加偏移量4形成操作数地址，取出操作数存入R0。后变址法：LDR R0，[ R1],#4; R1的值作为操作数的有效地址，取出操作数存入R0，将R1的内容加4来更新基址寄存器。 块拷贝：也叫做多寄存器寻址。快拷贝的地址变化方式：后增IA、先增IB、后减DA、先减DB。 STMIA R0,{R1-R3,R8};解释： [R0]&lt;—R1 [R0+4]&lt;-R2 [R0+8]&lt;-R3 [R0+12]&lt;-R8 堆栈寻址：堆栈的分类：满堆栈、空堆栈、递增堆栈、递减堆栈、满递增堆栈、满递减堆栈、空递增堆栈、空递减堆栈。 STMFD SP！，{R1-R3，R8}； 相对寻址：以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，相加后的地址即为操作数的有效地址。 BL SUB1;…SUB1:….MOV PC,LR； 指令系统单寄存器传送指令LDR和STR指令 LDR：加载字数据 从内存中将一个32位的字数据或一个8位的字节数据读取至寄存器中。 LDR {cond}{T} Rd，addressing;加载指定存储单元中的32位字数据到寄存器Rd。 STR：存储字数据 将一个32位的寄存器中的字数据或一个寄存器的低8位写入到指令指定的内存单元中。 STR {cond}{T} Rd，addressing; 存储Rd中的字数据到指定的存储单元中。多寄存器传送LDM和STM指令： （用途：保护现场、数据复制、参数传递等） LDM：多寄存器加载 将连续内存单元数据加载到若干个寄存器中。 LDMIA R1！，{R5-R7}；加载R1指向的存储区域的多字数据至R5-R7中 STM：多寄存器存储 将若干个寄存器的值放到连续的内存单元中。 STMIA R0！，{R5-R7}；将R5-R7的数据存储到R0指向的存储区域，R0更新 程序状态寄存器访问指令： (只有特权模式下可以修改状态寄存器) MRS：读状态存储器 MRS指令用于将状态寄存器的内容传送到通用寄存器中。这是程序获得程序状态寄存器PSR值得唯一方法； MRS R0，CPSR； 读取CPSR状态寄存器的值，保存到R0中。 MSR：写状态存储器 可以将一个寄存器的内容或一个立即数传送到CPSR和SPSR； MSR CPSR_c,#0xD3; 体系结构版本结构ARM7诺依曼结构ARM9哈佛体系结构ARM11ARMv6指令集体系结构 板级系统S3C2410X的存储系统特征 支持数据存储大/小断选择（通过外部引脚进行选择） 地址空间：具有8个存储体，每个存储体可达128MB，共计可达1GB 对存储体的访问位数可变（8位/16位/32位） 8个存储体中，Bank0~Bank5支持ROM,SRAM；Bank6、Bank7支持ROM、DRAM、SDRAM等。 7个存储体的起始地址固定，一个存储体的起始地址可变 I/O接口，I/O编址方式、数据传送I/O接口：即输入输出接口，是微控制器同外界交互的重要通道。在主机和外围设备之间的信息交换中起桥梁和纽带作用。 设置接口电路的必要性： 解决主机CPU和外围设备之间的时序配合和通信联系问题； 解决CPU和外围设备之间的数据格式转换和匹配问题； 解决CPU的负载能力和外围设备端口选择问题。 I/O接口的编址方式：独立编址、统一编址 独立编址：将存储器地址空间和I/O接口地址空间分开设置，互不影响。 设有专门的输入指令和输出指令来完成I/O操作。 统一编址：不区分存储器地址空间和I/O接口地址空间，把所有的I/O接口都当做是存储器的一个单元对待，每个接口芯片都安排一个或几个与存储器统一编号的地址号。 数据传送高阻输入，低挽输出，开漏输出 人机交互LCD控制方式LCD控制方式：总线驱动方式、控制器扫描方式 键盘设计键盘：是有若干个按键构成的开关矩阵，它是嵌入式系统中最简单的数字量输入设备，操作员通过键盘输入数据或命令，实现简单的人机通信。键盘的基本电路是一个接触开关，通、断两种状态分别表示0和1，微处理器可以很容易的检测到开关的闭合。 开发模式及工具调试方法调试方法：在线仿真器法、片上调试法、模拟器法 名称名称含义区别应用场景在线仿真器法在线仿真器（ICE）是一种用于替代目标机上的CPU的设备。效果最好、功能最全面、实时性最强的调试方法，但代价昂贵，通常仅在特殊情况下使用。ICE调试方法特别适用于调试实时的应用系统、设备驱动程序以及对硬件进行 功能和性能的测试。片上调试法片上调试（OCD）是CPU芯片提供的一种调试软件的功能。目前使用最广泛的的调试方法。不占用目标机资源，调试环境和最终的程序运行环境基本一致。支持软硬断点、跟踪、精确计量程序的执行时间、时序分析等功能。但实时性不如ICE强，不支持非干扰调试查询，CPU必须具有OCD功能。OCD存在各种实现，标准不唯一。模拟器法模拟器是在宿主机上模拟出一个虚拟目标机的硬件环境，可以在这个虚拟的硬件环境上运行基于此硬件环境的程序甚至操作系统，得到在真实硬件上运行的结果，进而达到在宿主机上运行和调试嵌入式程序的目的。最节约成本。可以在没有实际的目的机环境时开发其应用程序，并且在调试时可以利用宿主机的资源来提供更详细的错误诊断信息。但实时性差、不能模拟所有设备。应用场合：可以在没有实际的目的机环境时开发其应用程序 进程和线程进程与线程的比较 进程是多道程序设计的产物，线程是将并行性引入到进程内部，线程被称为轻量级进程。 进程是操作系统调度程序执行和分配系统资源的基本单位。 线程是操作系统调度程序执行的最小单位，是进程内部的一个执行控制流。 不同方面：调度和切换、执行过程、拥有资源、系统开销 结合具体 OS 分析 嵌入式Linux操作系统的进程和线程： 嵌入式Linux操作系统提供产生进程的机制。首先，使用系统调用fork() 复制当前进程的内容创建一个子进程，子进程与父进程的区别仅仅在于不同的PID、PPID和其他的一些资源。然后，执行函数exec() 读取可执行文件并将其载入地址空间开始运行。嵌入式Linux操作系统也提供了创建线程的API函数pthread_create()，通常可以将所要传递给线程函数的参数写成一个结构体，传入到该函数中。 WinCE操作系统的进程和线程： WinCE是基于优先级的抢占式多任务操作系统，一个应用程序对应一个进程，一个进程可以包含多个线程。进程本身不参加系统的调度，也没有优先级和上下文。进程创建时，会创建一个主线程作为该进程默认的执行本。 在WinCE中，线程是系统调度的基本单位，有运行、挂起、睡眠、阻塞、终止五种状态。 μC/OS-Ⅱ操作系统的进程 μC/OS-Ⅱ操作系统运行时，实质上是一个进程，而所谓系统任务、用户任务都是运行于操作系统进程环境中的线程。 μC/OS-Ⅱ操作系统提供了系统函数OSTaskCreate() 创建任务，每个任务有自己的堆栈空间、代码空间、但它们共享系统其他资源。 μC/OS-II特点开源、可移植性好、可固话、可剪裁、占先式、多任务、可确定性、任务栈、系统服务、中断管理、稳定性与可靠性、易学易用、支持教学与科研 任务调度策略P178为嵌入式任务管理 最短周期优先SBF 优先级法 轮转法 多对轮转法和多级反馈队列法 实时调度算法 P194为μC/OS-Ⅱ的任务管理 μC/OS-Ⅱ中有两种调度器：任务级调度器和中断级调度器。任务级的调度器由函数OSSched（）充当，中断级的调度器由函数OSIntExit（）充当。调度器的工作都是首先选择一个当前处于就绪态的优先级最高的任务，然后终止当前任务的运行，使新选出的任务投入运行。 表变量、组变量的认识μC/OS-Ⅱ使用两个变量OSRdyGrp和OSRdyTbl[]表示任务的就绪情况，OSRdyGrp是一个INT8U型的整数，简称组变量；OSRdyTbl[]是具有8个元素，元素数据类型是INT8U的数组，简称表变量。组变量特点：组变量是一个8位的无符号整数，取值范围从0~255，最多具有256个值。如果把组变量的每个取值n作为数组OSUnMapTbl[]的下标，组变量的值为n时所表示的具有最高优先级的任务所在的行号作为对应的数组的元素值。 通过查询组变量和表变量来确定处于就绪态的优先级最高的任务。 OSMapTbl[],OSUnMapTbl[] OSMapTbl[]是一个为了加快运算速度而定义的数组，一共8个元素。 下标与值的关系：表变量中的下标对应位置为1。例如OSMapTbl[0]=0b00000001； OSUnMapTbl[]中每个元素的值就是数组元素下标转化成二进制后，从低向高看第一个1所在的位的顺序号。 就绪操作的核心代码就绪任务的登记： OSRdyGrp &lt;span class=&quot;string&quot;&gt;|OSMapTbl[Prio &amp;gt;&amp;gt; 3];&lt;/span&gt; OSRdyTbl[Prio &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;string&quot;&gt;| = OSMapTbl[Prio &amp;amp; 0x07];&lt;/span&gt; `&lt;/pre&gt; 任务的删除： &lt;pre&gt;`&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((&lt;span class=&quot;constant&quot;&gt;OSRdyTbl&lt;/span&gt;[ prio &lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &amp;amp; = ~&lt;span class=&quot;constant&quot;&gt;OSMapTbl&lt;/span&gt;[ prio &amp;amp; &lt;span class=&quot;number&quot;&gt;0x07&lt;/span&gt; ] ) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;constant&quot;&gt;OSRdyGrp&lt;/span&gt; &amp;amp; = ~&lt;span class=&quot;constant&quot;&gt;OSMapTbl&lt;/span&gt;[ prio &lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]; `&lt;/pre&gt; 寻找高优先级任务的方法 &lt;pre&gt;`&lt;span class=&quot;setting&quot;&gt;y = &lt;span class=&quot;value&quot;&gt;OSUnMapTbl[OSRdyGrp];&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;setting&quot;&gt;prio= &lt;span class=&quot;value&quot;&gt;( y &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) + OSUnMapTbl [ OSRdyTbl [ y ] ];&lt;/span&gt;&lt;/span&gt; μC/OS-II 扩展FSμC/FS是一种几乎可以运行在所有介质上的基于FAT（文件分配表）的文件系统，前提是这种介质能提供基本的访问功能。μC/FS针对不同的设备，在速度、内存使用等方面进行了很好的优化，具有良好的性能。μC/FS体系结构，由四个层次组成： GUI嵌入式GUI的特点：具有较高的性能，可以满足基本的应用需求；运行时占用较少的资源，体积小；具有较高的可靠性；上层接口与硬件无关，易于剪裁，易于移植。 μC/GUI被设计成用于给使用一个图形LCD的任何应用程序提供一个高效率的，与处理器核LCD控制器无关的GUI。 应用开发流程 系统需求分析 体系结构设计 软硬件及机械系统设计 系统集成 系统测试 最终产品","link":"/2015/06/08/嵌入式复习/"},{"title":"操作系统复习","text":"进程控制块PCB包含哪些内容； 标识信息 又称进程名或进程号，唯一数值编号 描述信息 进程状态，程序代码位置，数据存放位置 现场信息 管理和控制信息 操作系统通常采用的处理器两态模式：核心态（管态）. 用户态（目态）； 操作系统的定义；P1 管理系统资源、控制程序执行、改善人机界面、提供各种服务，合理组织计算机工作流程和为用户方便而有效地使用计算机提供良好运行环境的最基本的系统软件。 进程三态模型的变迁；课本P22 运行态：发生等待事件→等待态；时间片到→就绪态 等待态：等待事件结束→就绪态 就绪态：调度→运行态 （创建态→就绪态） （运行态→终止态） [计算]多道程序系统中，多道作业运行完成最少时间的计算，参照讲过的题目； P19页 例题2-1、2-3 输入井的四种状态；P137 输入状态 后备状态 执行状态 完成状态 Linux中，详细列出当前目录下所有扩展名是.c文件信息的命令；P192 ls -l *.c Linux中，gcc在每一次编译连接程序时，默认生成的可执行程序是a.out，而且将覆盖上一次生成的a.out。说法对吗？P178 line:4 对 Linux命令ls | grep old中的“|” 是什么操作符； P192 管道使用符号 操作系统通常采用逻辑扩充内存的技术来解决内存容量不足的问题，主要方法有哪三种？P83 覆盖技术 交换技术 虚存技术 常用的可变分区管理中的分配算法；P91 最先适应 最佳适应 最坏适应 下次适应 文件控制模块（FCB）的定义；P144 为能对文件进行正确的存取，计算机系统为文件设置了一系列描述和控制信息，这些信息以一个数据结构的形式表示，人们称此结构为文件控制块。 多级反馈队列轮转（Round Robin with Multiple Feedback）调度算法是一种综合的进程调度算法，该算法是LRU算法. 时钟算法和OPT算法的综合应用，说法对吗？P 错，多级反馈队列轮转(Round Robin with Multiple Feedback)是时间片轮转算法和优先级调度算法和先来先服务算法的综合应用。 LRU算法、时钟算法和OPT算法是页面置换算法。 进程控制是通过系统调用进行的吗？P25 不是。进程的控制是在操作系统的内核中采用进程控制原语进行。 一个进程资源分配图是不可完全简化的，那么就一定发生了死锁？死锁定理 死锁定理。在死锁检测时，可以利用把资源分配图进行简化的方法来判断系统当前是否处于死锁状态。具体方法如下： ① 在资源分配图中，找出一个既非阻塞又非孤立的进程结点Pi。如果Pi可以获得其所需要的资源而继续执行，直至运行完毕，就可以释放其所占用的全部资源。这样，就可以把Pi所有关连的资源分配线和资源请求线消去，使之成为孤立的点。 ② 重复进行上述操作。在一系列的简化后，如果消去了资源分配图中所有的箭头线，使所有进程结点都成为孤立结点，则称该资源分配图是可完全简化的；反之，则称该资源分配图是不可完全简化的。 如果当前系统状态对应的资源分配图是不可完全简化的，则系统处于死锁状态，该充分条件称为死锁定理。 利用Hash方法建立的文件结构称为Hash文件，这种物理结构适用于不宜采用连续结构，记录次序较混乱，又需要快速存取的情况，说法对吗？P150 Hash文件 对。Hash文件定义 目前用的缓冲技术是硬件缓冲和软缓冲，缓冲区大小不随意修改；P126~127 硬件缓冲：一般指在设备控制器中设置数据缓冲寄存器，用于暂时存放传输的数据 软件缓冲：在贮存中开辟一块特定区域用来做缓冲区，优点是数量和大小可以改变，缺点是需要占用主存空间。 不同的计算机系统，其通道命令的格式是不相同的；P122 进程之间的状态变化，一定在PCB中反映出来；P23 进程控制块的描述信息中包含进程当前所处的状态。 页式管理中，地址结构具有一维性质，而在段式管理中，地址结构具有二维性质； 多道系统环境下，操作系统分配资源是以进程为基本单位； 处理器调度有哪些？ 低级调度：进程调度（P28） 中级调度：挂起调度，也称交换技术 （P84） 高级调度：作业调度 （P28） 在可变分区的存储管理中，回收一个分区时，空闲区个数减少1个的情况；P89，例3-2 两个空闲区之间的作业完成被回收时，该作业原来所占分区和它前后两个分区也就是三个空闲区自动合并为一个空闲区，这时空闲区的总数会减少1。 引入文件系统的主要目的；P143 方便文件的访问和控制、多线程支持文件的并发访问、提供统一的用户接口、多种文件访问权限、优化性能、验证文件的正确性、恢复差错等，为用户和底层硬件之间建立了文件管理的桥梁。 用户可以调用关闭操作来归还文件的使用权；P153 了解信箱的消息传递方式；P67 采用信箱的消息传递方式是一种简洁的通信方式。通信的双方通过信箱来交流信息，从而避免了直接通信方式下通信双方必须以会合的方式进行。采用信箱通信方式的Send()原语和Receive()原语形式如下： Send(Mailbox,Message) Receive(Mailbox,&amp;Message) 不安全状态和死锁状态之间的关系；P74 不安全状态 假如当前系统的可用资源，找不出一种进程申请序列，能够使所有的进程都能在有限时间内完成，那么这种状态称为不安全状态。不安全状态不一定是死锁状态，这是因为，并不是所有的进程都需要达到最大需求量的资源才能运行完毕 死锁状态 如果系统的一个进程集合中的每个进程都在等待只能由该进程集合中的另一进程才能引发的事件，这时系统就处于死锁状态。死锁肯定是不安全状态 Windows 2000/XP 中，exit() 函数会销毁所有全局的或静态的C++对象，然后促使操作系统终止应用程序； [计算]虚拟地址空间的计算；P104 2^(计算机系统的位数)B； 例如：操作系统是32位，虚拟地址空间为：2^32B=4GB 进程的概念；P20 进程是并发环境下，一个具有独立功能的程序在某个数据集上的一次执行活动，它是操作系统进行资源分配和保护的基本单位，也是执行的单位。 存储管理的主要任务；P83 内存的分配和回收 地址转换 内存的共享和存储保护 内存的扩充 为什么要用缓冲区技术？常用的软件缓冲技术有哪些？ 使用缓冲技术的原因： 协调CPU与I/O设备之间速率不匹配 协调逻辑记录与物理记录（物理块）大小不一致 解决DMA控制方式或通道方式下可能出现的进程长时间等待问题 常用的缓冲技术： 单缓冲技术 双缓冲技术 多缓冲技术 缓冲池技术 为什么要做记录的成组和分解？有什么优点和缺点？ 原因：采用记录的成组和分解有利于提高存储空间的利用率，减少启动存储设备的次数。 优点：提高磁盘存储效率，减少磁盘驱动调度次数，提高系统性能。 缺点：需要软件进行成组和分解的额外操作；需要能容纳最大块长的输入输出缓冲区。 [计算]使用快表与否对存取时间的影响，会计算； P97 例3-6 [计算]磁盘物理块与逻辑块之间的换算，会计算； P96 例3-5 [计算]FIFO和LRU算法； FIFO：P107 例3-7LRU： P108 例3-8 [计算]作业调度中，先来先服务，短作业优先策略和最高响应比调度策略，会列表计算；但注意题目，以往我们都说是多道系统下，因为采用的不可抢占方式，一道作业被调度就必须运行结束下一个作业才能调度，所以也可以说成是在单道串行方式下采用这些调度策略，具体做题方法和步骤与作业一样； 复习：P16 习题9 孙钟秀版教材P123页介绍最高响应比调度策略 [计算]移动臂调度算法，先来先服务. 最短寻道时间优先和电梯调度算法； P135 例4-4 [计算]P.V操作解决同步与互斥问题，看例题和作业题。 互斥问题：P49 例2-9 同步问题：P54 例2-10 进程与线程的比较；P35 并发性：系统进程可以并发执行，线程也可以并发运行 资源分配和占有：进程是资源分配和保护的基本单位，线程几乎不拥有资源 系统开销与效率：进程需要系统分配和回收资源，线程由于不拥有资源开销要比进程小得多 调度效率与灵活性：进程是资源分配和保护的基本单位，进程拥有资源；线程是系统调度和分派的基本单位，不拥有资源，但可以访问该进程的资源，所以调度和切换简单易行，线程的切换不会导致进程切换，因此系统效率高，并发度也大大提高。 文件的逻辑结构有哪些？P147 无结构字符流式文件 有结构记录式文件 连续结构 顺序结构 I/O控制方式 P123 I/O通道控制方式： 字节多路通道 数组选择通道 数组多路通道","link":"/2015/01/09/操作系统复习/"},{"title":"编译原理复习","text":"第一章 总论 编译原理=形式语言+编译技术 编译程序的输入数据是源程序，输出结果是目标程序。 程序设计语言的定义涉及：语法、语义、语用、语境。 汇编程序：把汇编语言程序翻译成等价的机器语言程序（机器指令序列） 编译程序：把高级语言程序翻译成等价的机器语言程序（目标程序） 程序的翻译的两种方式：解释方式和翻译方式 解释执行方式： 解释程序，逐个语句地模拟执行 翻译执行方式： 翻译程序，把程序设计语言程序翻译成等价的目标程序 计算机程序的编译过程，一般分为五个阶段：词法分析、语法分析、语义分析及中间代码生成、代码优化、目标代码生成。 编译程序与具体的机器无关，与具体的语言有关。 词法分析的任务：扫描源程序的字符串，识别出的具有独立意义的最小语法单位（标识符或无正负号数等） 语法分析是：语法分析读入词法分析程序识别出的符号（属性字序列，词），根据给定的语法规则，识别出各个语法结构。在词法分析的基础上的，语法分析不考虑语义。 语义分析的任务是检查程序语义的正确性，解释程序结构的含义，语义分析包括检查变量是否有定义，变量在使用前是否具有值，数值是否溢出等。语法分析完成之后，编译程序通常就依据语言的语义规则，利用语法制导技术把源程序翻译成某种中间代码。所谓中间代码是一种定义明确、便于处理、独立于计算机硬件的记号系统，可以认为是一种抽象机的程序 代码优化的主要任务是对前一阶段产生的中间代码进行等价变换，以便产生速度快、空间小的目标代码编译的最后一个阶段是目标代码生成，其主要任务是把中间代码翻译成特定的机器指令或汇编程序 编译划分成前端和后端。 编译前端的工作包括词法分析、语法分析、语义分析。编译前端只依赖于源程序，独立于目标计算机。前端进行分析。 编译后端的工作主要是目标代码的生成和优化后端进行综合。独立于源程序，完全依赖于目标机器和中间代码。 把编译程序分为前端和后端的优点是：可以优化配置不同的编译程序组合，实现编译重用，保持语言与机器的独立性。 编译程序的分类： 诊断型编译程序（找错） 优化型编译程序（产生空间小速度快） 交叉型编译程序（一些设备上的嵌入式应用软件一般是在另外类型的计算机上设计和开发，经过编译、运行、和测试后再经过一次编译产生出在上述设备上可以运行的目标代码这类编译程序称之为交叉型编译程序） 可变目标型编译程序Lex是通用的词法分析生成器，它的输入是描述单词结构的正规式，输出的就是词法分析程序。 预处理器：它是在编译程序真正开始翻译源程序之前调用的一个独立的程序，以便加快和简化翻译工作。预处理器可以删除源程序中的注释、空格符等与程序无关的部分，执行宏代换等工作 第二章 文法和语言 符号，字母表，符号串，符号串的长度计算 P18，子符号串的含义，符号串的简单运算XY ，Xn， 符号串集合的概念，符号串集合的乘积运算，方幂运算，闭包与正闭包的概念 P19，P20 A0 ={ε} 重写规则，简称规则。非终结符（Vn），终结符（Vt）的概念。 文法的概念。P23 识别符号.P23 文法的第一个重写规则的左部符号为识别符号。BNF表示法 P6 直接推导和直接规约，广义推导广义规约，P24 最左推导，最右推导P62 句型和句子 P26，短语，简单短语，句柄P26，P27对于文法G，仅包含终结符的句型称为句子。一个句型的最左简单短语称为该句型的句柄。 语言的定义 P31 递归，左递归P32，消除左递归P51 文法的形式化定义 P36 定义 0型文法，短语结构文法 1型文法，上下文有关文法 CSG 2型文法，上下文无关文法 CFG 3型文法，正则文法RG 3型语言类（2型语言类（1型语言类（0型语言类 但四种语言本身之间没有必然的包含关系 P38 3型语言的定义 有穷状态自动机 P41 2型语言 下推自动机 1型语言 线性界限自动机 0型语言 图灵机 一个语言的文法是不唯一的。 递归文法的定义。递归文法产生的句型有无限多个 文法的压缩P50，消去规则左递归P51（看例题2.24） 语法分析树的构造，能够根据语法树来寻找短语，直接短语，句柄。(P66习题2的第3条)掌握最左推导和最右推导 文法的二义性问题P60，文法的二义性是不可判定的。某文法的同一个句子存在两个不同的语法分析树，则称该文法是有二义性的。 第三章 词法分析 词法分析的功能 P69，词法分析的语法基础是正则文法 词法分析器可以有两种实现模式：完全融合模式（大多采用）和相对独立模式，完全独立方式 P71 有穷状态自动机的概念，如何从正则文法构造有穷状态转换自动机 P72(例3.1) P116习题6第1题 如何从有穷状态转换自动机构造正则文法P74 正则文法是无二义性的。能被确定有穷状态自动机识别的语言，一定能用正则表达式表示。 知道确定有穷状态自动机DFA五元组（K，Σ，M，S，F），五个字母的含义。P75 非确定有穷状态自动机NFA，如何将NFA转化为DFA P82 （看懂表3-3）P117习题6第6题，8. DFA的化简，P85（例3.7）习题6第8题 NFA和DFA的含义与区别NFA不确定的有穷自动机，DFA确定的有穷自动机。NFA即假如一个输入符号，可以得到两个或者两个以上可能的状态，也就是说得到的可能的状态是不确定；DFA即假如一个输入符号，只能得到唯一的一个可能的状态。对于DFA，一个特定的符号输入，有且只能得到一个状态，而NFA就有可能得到一个状态集。 属性字由符号类和符号值组成。特定符号类，一个符号类对应一个符号值：关键字、括号，运算符。非特定符号类：标示符，无符号整数。符号类识别不同类的符号，符号值识别同类的不同符号 P90 字符表，符号机内表示对照表，标示符表，无符号整数表各自的定义和作用P93 词法分析程序的大致思路 第四章 语法分析-自顶向下 语法分析的文法基础是上下文无关文法 语法分析的两大类分析方法是自顶向下分析法和自底向上分析法。 带回溯的自顶向下分析方法P121 （一般采用最左或者最右推导） 预测分析技术：消去规则左递归的方法P51；构造first集合和follow集合P138，构造预测分析表P139 输出计算过程本身的方法 P134 LL（1）文法的定义 P140 语法分析树建立的方式可以分为自顶向下与自底向上两大类分析技术。 无回溯的自顶向下的预测分析技术需要文法满足两个条件：无回溯和无左递归。P125 第五章 语法分析-自底向上 规范分析：最右推导被称为规范推导，最左规约被称为规范规约。 P145 自底向上语法分析方法的基本思想是，利用文法的规则逐步向上进行规约，直到文法的识别符号。 分析所需要解决的两个基本问题：找出要被归约的短语u；确定归约到哪个非终结符号U 一个符号串的前缀是指该串的任一部分。一个规范句型的前缀若不含句柄之后的任何符号就称为活前缀 基本方法：移入规约法 P147 四个动作之一：移进归约接受出错 算符优先分析技术： P150 定义5.2 构造算符优先关系表 P151-154 算符优先识别算法P１５５重点掌握FIRSTTERM集合和LASTTERM集合的计算方法 ? LR(k)分析技术 ,要知道其中定义:圆点在产生式最右端的项目称为可归约项，如E→E+T· ；圆点后面是终结符的项目称为移进项 ，如E→E·+T ； 圆点后面是非终结符的项目称为待约项 ， 如E→E+·T。项，项集，项集的闭包特征有穷状态机 CFSM. P183。 CFSM表中无不适定状态的称为LR(0) 文法SLR（1）文法：各个简单向前看k集合互不相交 P191LALR文法：构造LR（1）项，然后合并同心项，生成LALR 规约冲突 P199LR（k）文法。 第六章 语义分析与生成目标代码 语义分析的基本功能：确定类型；类型检查；识别含义，作相应的语意处理；其他一些静态语义检查。 P215 语义分析以语法分析部分的输出（语法分析树或其他等价内部中间表示）为输入，输出中间表示代码，甚至目标代码。 P215 语义是上下文相关的 语法制导翻译技术 中间代码生成依据语言的语义规则 抽象语法树的画法 P297 逆波兰式的生成 P300 四元式的生成 P306 三元式 第七章 运行环境 代码优化的定义 P348 ：是在编译时刻为改进目标程序的质量而进行的各项工作。改进质量以提升时间效率和空间效率两方面。 注意点：代码优化进行的是等价变换，为优化进行努力应当是值得的。 基本块的概念， 对基本块的优化：合并常量计算，消除公共子表达式，消减计算强度，删除无用代码。对循环的优化：循环不变表达式外提，归纳变量删除，计算强度消减。 代码优化的三个过程：控制流分析，数据流分析，变化。 P350 各自的含义 代码优化是基于中间表示代码进行的 窥孔优化： 定义 P395 包括：四种典型优化，各自的含义、","link":"/2015/06/28/编译原理复习/"},{"title":"软件工程复习","text":"软件工程与计算机科学性质不同，软件工程侧重于建造软件系统。 软件工程三要素是：方法、工具和过程。 “软件危机”(Software Crisis)的出现是由于软件的规模越来越大，复杂度不断增加，软件需求量增大。而软件开发过程是一种高密集度的脑力劳动，软件开发的模式及技术不能适应软件发展的需要。致使大量质量低劣的软件涌向市场，有的花费大量人力、财力， 而在开发过程中就夭折。软件危机主要表现在两个方面：软件产品质量低劣，甚至开发过程就夭折；软件生产率低，不能满足需要。 软件生存周期模型有多种，包括瀑布模型、增量模型、螺旋模型、喷泉模型、智能模型。螺旋模型中包含了风险分析。 瀑布模型是文档驱动，按照严格线形规划的软件生存期模型。 原型模型又称快速原型模型，它是增量模型的另一种形式。根据快速原型运行的目的，可以将软件原型分为废弃型、追加型。 实时处理软件一般对性能的要求很高，可选用的语言有汇编语言，ADA语言。 软件质量保证是向用户提供满意的高质量软件，确保软件产品从可行性分析到运行与维护为止的所有阶段的质量活动。 测试用例应由测试输入数据和对应的预期输出结果这两部 分组成。 软件工程包括软件开发技术和软件工程管理两个部分内容。 结构化程序设计的指导思想是自顶向下、逐步求精 过程设计语言简称PDL，又称为伪码，它是一种用于描述模块算法设计和处理细节的语言。 面向对象的主要特征是抽象性、封装性、继承和多态性 用户界面设计最重要的目标是可使用性，设计人机交互子系统时，需要把用户的使用习惯作为考虑的重要因素。 为了识别和纠正在运行中产生的错误而进行的维护称为校正性维护，为了使应用软件适应计算机硬件、软件及数据环境所发生的变化而修改软件的过程称为适应性维护。 人们常用的评价软件质量的4个因素是可维护性、可靠性、可理解性和效率。 DFD图（数据流图）是常用的进行软件需求分析的图形工具，通常之后采用数据字典对图形的内容进行详细说明。画DFD图的主要目的是作为需求分析阶段用户与开发者之间交流信息的工具和进行分析与设计的工具。数据流图中的数据字典包括：数据流条目、数据项条目、文件条目、加工条目。 分层DFD图遵循的基本原则有：数据守恒与数据封闭、加工分解、子图与父图平衡 UML类图的关系包括：继承、实现、依赖、关联、聚合、组合。关联是建立类之间关系的一种关系 对象模型的主要元素是类、关联和关系。 UML语言支持的建模方式有静态建模、动态建模。动态模型描述了系统的动态行为。 软件项目管理的主要职能包括人员管理、计划管理、成本管理、进度管理。软件工程管理的任务和目标包括：明确软件开发项目的工作范围、可能遇到的风险、需要的资源；明确软件开发中要实现的任务和需要经历的里程碑；明确所需工作量以及进度安排等等。 软件复用的形式分为横向复用和纵向复用。 基于构件的软件开发方法的优势主要有：有利于提高软件的质量和可靠性。有利于提高软件的开发效率。降低软件开发成本。 面向对象的开发方法包括Booch、Coad/Yourdon、OMT（对象模型技术）、OOSE方法。 软件结构的设计目标应该是高内聚、低耦合。 重用率高的模块在软件结构图中的特征是扇入度高。 白盒法又称结构测试、逻辑驱动测试或者基于程序的测试，在理解程序的内部逻辑的前提下，设计测试用例尽可能的覆盖程序的执行路径。黑盒法又称功能测试、数据驱动测试或者基于规格说明的测试，把待测试的程序当成一个黑盒，在不考虑程序内部结构和内部特性的情况下，对程序进行功能测试。白盒法主要用来分析程序的内部结构，开发人员一般用此方法进行程序的测试或者调试。黑盒法用来证实软件功能的正确性和可操作性，测试人员一般用此方法来对软件进行测试。 白盒测试法中的逻辑覆盖包括六种覆盖标准：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。发现错误的能力呈由弱至强的变化。 语句覆盖：每条语句至少执行一次。判定覆盖：每个判定的每个分支至少执行一次。条件覆盖：每个判定的每个条件应取到各种可能的值。判定/条件覆盖：同时满足判定覆盖条件覆盖。条件组合覆盖：每个判定中各条件的每一种组合至少出现一次。路径覆盖：使程序中每一条可能的路径至少执行一次。 循环覆盖包括：单循环、嵌套循环； 黑盒测试注重测试软件的功能需求，用黑盒技术测试用例的方法一般有以下四种，等价类划分、边界值分析、错误推测、因果图。 常用的静态测试方法包括：桌前检查、代码会审、步行检查。 集成测试是指：在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或完整的系统而进行的测试。重点测试模块的接口部分，需设计测试过程所使用的驱动模块和桩模块，测试方法以黑盒法为主。 软件维护的类型中包括：完善性维护、纠错性维护、适应性维护、预防性维护，其中最重要的是完善性维护。 α测试是在开发机构的监督下，由个别用户在确认测试阶段后期对软件进行测试，目的是评价软件的功能、可使用性等方面。 β测试是由软件产品的全部或部分用户在实际使用环境下进行的测试，整个测试过程是在用户的独立操作下完成的，没有软件开发人员参与。 CASE是计算机辅助软件工程的简称。它的实质是为了软件开发提供一组优化集成的软件开发工具， 其目的是实现软件生存期各个环节的自动化并使之成为一个整体 。CASE不同于独立的单个软件开发工具，它将软件开发不同阶段的工具进行集成，使其具有统一的界面和可以共享的信息数据库。 CMM是指“能力成熟度模型”，是对于软件组织在定义、实施、度量、控制和改善其软件过程的实践中各个发展阶段的描述。CMM的核心是把软件开发视为一个过程，并根据这一原则对软件开发和维护进行过程监控和研究，以使其更加科学化、标准化、使企业能够更好地实现商业目标。初始级、可重复级、已定义级、已管理级、和优化级。 提高软件的可维护性的方法：在软件工程的每一阶段都应该努力提高系统的可维护性，在每个阶段结束前的审查和复审中，应着重对可维护性进行复审。 在需求分析阶段的复审中，应对将来要扩充和修改的部分加以注明。在讨论软件可移植性问题时，要考虑可能要影响软件维护的系统界面。 在软件设计的复审中，因从便于修改、模块化和功能独立的目标出发，评价软件的结构和过程，还应对将来可能修改的部分预先做准备。 在软件代码复审中，应强调编码风格和内部说明这两个影响可维护性的因素。 在软件系统交付使用前的每一测试步骤中都应给出需要进行预防性维护部分的提示。 在完成每项维护工作后，都应对软件维护本身进行仔细认真的复审。为了从根本上提高软件系统的可维护性，人们正试图通过直接维护软件规格说明来维护软件 ，同时也在大力发展软件重用技术。 会画DFD图，会写数据字典。 会根据覆盖度写测试用例。 覆盖强度 覆盖度名称 解释 由 语句覆盖 每个执行语句至少执行一次 弱 判定覆盖 每个判定至少获得一次真或假 到 条件覆盖 判定中的每个条件至少获得一次真或假 强 判定-条件覆盖 判定覆盖和条件覆盖同时满足 条件组合覆盖 判定中条件的每种组合都至少出现一次 会画UML用例图，状态图。 会计算生产率。 一直条件：开发人员数（人），单个程序员开发效率（行/年），通信成本（行/年） 小组生产率 = 开发人员数 * 单个程序员开发效率 - 通信成本 * 通信路径数 其中 通信路径数 = 开发人员数 * (开发人员数 - 1)/2 单选10题10分，填空题20空20分，判断题10分，名词解释3题15分，简答题4题20分，案例分析2题25分。","link":"/2015/01/06/软件工程复习/"},{"title":"2013年8月迅雷病毒事件","text":"(本文由知乎 @陈彪 整理) 以下为雷锋网 2013 年 8 月 1 日文章（目前已被删除），摘自谷歌缓存： 《迅雷惊现“掘雷者” 高层包庇共谋私利》 继京东商城那位叫吴声的同志首创了“食京者”后，迅雷也出现了“掘雷者”。近日，迅雷看看就有高层利用职务之便对看看的用户进行了病毒般的强制插入，捆绑了众多软件，行为极其恶劣，已构成了职业犯罪。但可笑的是，这个事在迅雷内部竟然没起任何波澜。不知道是公司反应慢，还是这些人只手遮天的能力实在太强。不多说了，看下边内容。（编者注：以下内容为迅雷内部针对此事的内部邮件） 邮件一 这封邮件是工作人员在收到迅雷看看的用户反馈，分析后发送邮件抄送迅雷各大高管以及迅雷看看高管，认为此事件是给用户安插病毒，给个别人谋取私利。 昨天接到用户反馈，发现一个位于 C:\\Windows\\System32 目录下，名为 “INPEnhSvc.exe” 带有迅雷数字签名的文件。（见附件INPEnhSvc.exe） 我们从用户机器上将此文件取回，经技术人员逆向分析，发现该文件有病毒行为。 “INPEnhSvc.exe” 是一个服务，加 /regserver 参数可注册启动。 启动后有3次服务器连接，访问2个域名分别为：http://conf.kklm.n0808.com （下发配置文件）http://kkyouxi.stat.kankan.com从http://n0808.com 中拉取2个配置文件。（见附件1 2 3.txt） txt 配置了程序行为，检测到 “ taskmgr.exe | tasklist.exe | procexp.exe | procmon.exe | devenv.exe | windbg.exe | filemon.exe|ollyice.exe | ollydbg.exe | processspy.exe | spyxx.exe | cv.exe | wireshark.exe ” 等分析工具会自动退出，防止被发现。 txt 配置了如下 apk，满足某些条件，该程序会后台下载安装 adb（安卓手机驱动），并将如下 APK 自动安装到连接至当前计算机的手机上。http://down4.game.uc.cn/wm/4/4/JYqpdtV2.0.0.38_ddz_Android_Build20130624_48004_1538390bd246.apk （九游棋牌大厅）http://dl.sj.91.com/business/91soft/91assistant_Andphone_lite134.apk （91手机助手）http://shouji.360tpcdn.com/360sj/adm/apk/20130709/com.qihoo.appstore_199801_143149.apk （360手机助手）http://wap.uuwldh.com/down/1263/uuwldh_1263.apk （UU网络电话）http://down.gfan.com/gfan/product/a/gfanmobile/beta/GfanMobile_web414.apk （机锋应用市场） 程序内还有”设置IE首页、创建桌面快捷方式、添加IE收藏夹“等行为，都由 2.txt 这个配置文件配置。 外界已经有人注意到该文件，我们昨天已经排除文件通过迅雷7客户端部署的可能性，但由于带有迅雷数字签名，会导致用户迁怒于迅雷7，将迅雷7卸载。 邮件二 这封邮件是迅雷开发部门一位高管非常愤怒，将此邮件上升了高度，并认为有人在利用职务之便进行商业犯罪，要求彻查此事。 发现带有迅雷数字签名的未知文件，经分析有病毒行为我和我的小伙伴们都惊呆了！！代表迅雷的一名开发人员表示震惊和愤怒！！！！ 从该exe的特征和行为来看，属于典型的后门软件和病毒，并且使用类似云指令的技术来强制后台推送用户不需要的东西，来达到不可告人的目的，堂堂迅雷竟然能出现如此无耻下流的软件，若被杀毒软件拦截列入黑名单，后果不堪设想，迅雷长期积累的信誉将毁于一旦！迅雷公司的数字签名也可能陷入万劫不复的境地，祸及公司广大的产品包括迅雷7、xmp以及BOLT引擎等等众多产品和模块，不能不让人震惊！ 该软件带有迅雷数字签名，只有两种情况，一种是泄露数字签名导致，一种是内部员工和团伙所为。从规模来看，涉及到客户端开发(并且具有一定的反逆向保护)、外网服务器，云指令推送，服务器管理后台等技术，并且使用了http://kankan.com 的域名，推送apk肯定还涉及商业利益链包括揽活、销赃等，所以可以确定内部团伙作案的可能性非常大，凭一己之力很难做到这么大规模，并且外网高手即使有数字签名，也不大可同时控制http://kankan.com 下的域名。 客户端样本我也拿到一份，不得不说可笑，只凭此鸡鸣狗盗的雕虫小技就想鱼目混珠，瞒天过海？置迅雷的广大开发人员于何处？后台自动下载apk强制安装，众所周知当前手机应用推广的利润率惊人，单次安装激活就有1元到数元，所以这个软件究竟在发现之时已经散步到多大市场？后面的灰色利益链又是如何？幕后黑手又是谁？ 从google搜索结果来看，外网已经有众多用户反馈和抱怨，从反馈用户的ip来看，多是出于二三线小城市，真是用心良苦！！！如果是内部员工所为，那么作为迅雷的开发人员，以权谋私，利用公司的渠道尤其是下载部的迅雷7来满足私欲，为所欲为，不计后果，缺乏最基本的职业素质，令人不齿！ 恳请公司彻查此事，给所有开发人员一个交代： 1.请专业杀毒软件公司比如金山来分析病毒样本，出具病毒分析报告 2.从http://kkyouxi.stat.kankan.com 域名出发，顺藤摸瓜找出作案人 3.发掘该病毒的利益链条，找出幕后黑手 4.严格控制数字签名，采用更安全的机制来控制签名流程，保证所有被签名文件可回溯，杜绝可能的数字签名泄露 邮件三 这封邮件是迅雷看看先是找了某中层出来顶罪，并找各种理由来搪塞。 首先先给大家道歉一下，此次事故是近期我们推出的OFFICE插件的产品BUG所导致的问题，INPEnhSvc.exe是Office插件系统的守护程序，负责拉取配置与上报统计；INPEnhUD.exe是自升级程序，负责拉取升级配置升级Office插件系统。但旧版本的升级程序有Bug，导致守护程序不存在时拉起会弹框报错，守护程序自身也有内存泄漏的问题，所以在25号发了一个自升级版本修复这两个问题，降低对用户的影响，目前产品还在持续完善中。 至于推送九游棋牌大厅、91手机助手、360手机助手、UU网络电话、机锋应用市场的事情，是之前经过F总审批用于置换对应平台广告位置，来推广无线看看APK之用。2013年我们设定的无线看看的日新增目标数量达 到15万每天，根据之前邮件中的价格1元到数元来看的话，那么一天就是15万元RMB起，一个月就是450万，一年就是5400万RMB。而公司给到的预算只有800万用于无线推广，目前还都用在了和品牌硬件厂商合作预装上面，如果不通过换量很难完成任务目标。同时，迅雷所有无线产品的量都非常小，很难实现等价兑换，无奈之下才破例采取插件推送的形式进行换量操作。 其中九游棋牌大厅为UC浏览器的产品，其他的就不用介绍了，通过帮他们推广手机端应用，他们来帮我们推广无线看看，达到换量的目的。从实际效果来看，我们帮他们带量的情况很不乐观，部分平台仅为他们帮我们带量的十分之一。下面是他们帮我们推广产品的截图，带量情况及推广的排期表（实际执行远大于这些排期），请大家查看！ 最后，由于功能BUG给用户带来的问题，我们25号的升级版本已经解决，目前正在升级中，在此我们也深表歉意。但是仍然由衷希望大家在没调查好事实真相前，不要随意猜测，这样不仅影响内部团结，而且不利于解决已经发生和未来有可能会出现的问题，谢谢! 邮件四 这封邮件是迅雷客户端一位高管对迅雷看看中层顶罪表示愤怒，并将该事危害程度拔高。 作为迅雷客户端的维护人员，无论是谁出于何种初衷通过何种手段部署了这个程序，从结果上来看，迅雷客户端的声誉已经首当其冲的受到了严重损害，已经成为用户怒而卸载迅雷的原因，已是我的职责所在，很关心这个事情的进展。 现在已经澄清了是业务团队为了更好的实现置换推广为之，并非严重的安全问题。本来可以藏的很好，不被用户，甚至自家的开发人员感知，只是因为出了内存泄漏的bug才被大家关注起来，把bug解了这事就解决了？能否定这是一种病毒行为？藏的再好，也怕用户找；杀毒软件现在没报，以后就不会报？现在反馈的少，以互联网的传播速度也许哪天就大爆炸。 及早被发现难道不是好事？迅雷平台有很多更加正常，更加优雅，更加对用户友好的的推广渠道，为何不考虑？ 看一下这个程序的行为：带着迅雷的数字签名，以迅雷的名声作保，做的是静默下载并且安装App到用户手机，更改用户收藏夹之类的事情，加上一些反调试保护，无法停用无法删除。 这是严重伤害用户体验的活脱脱的病毒行为，不知情的开发人员看到这种程序的第一想法一定是“这是个病毒呀，迅雷不应该干这个，太伤名声了”，“谁为了啥干的”之类的猜测是非常正常的，为公司利益着想讨论问题细节并且希望彻查以儆效尤为先而作言，而不是为了所谓团结而沉默。 置换推广的策略是非常正确的，我想这也是领导审批通过的原因吧。但是执行手段是这样的病毒行为，和公司推行用户体验至上的原则是背道而驰的。 迅雷一丝一毫的用户体验改进都是各位同学殚精竭虑通宵达旦的辛苦付出得来的，迅雷一点一滴的用户口碑积累都是经年累月长期沉淀出来的，为了节省金钱和时间成本，采用这样的手段，对用户体验和迅雷口碑的伤害难道不是让公司付出了更大的成本？不是审毫毛小计而遗天下大数？岂非饮鸩止渴杀鸡取卵，涸泽而渔焚林而猎？ 如果这样的行为被认可，必然有人趋之如骛，置公司的整体利益于何地，其他同学的劳动于何地？想到这个令人不寒而栗。 由衷希望以病毒形式来推广的做法立即停止，而不是改了bug继续来。 位微言轻，不吐不快。 邮件五 这封邮件是迅雷看看某高管将此事定性为业绩压力太大所致。 此次事故来自业绩压力所为，初衷是为了推广公司的无线产品，执行方式虽是无奈之举，但是确实伤害了用户体验，目前已经全面停止，后续将不会出现类似的情况，避免给公司带来损失，后续还请大家多多监督。 邮件六 这封邮件是迅雷看看大boss再度对此事开脱。 首先，作为看看的负责人，这次的事情给了我一个深刻的教训，侥幸心理不能存在，对待任何事情都要思考得更全面。 一方面，同意程浩的处罚规定，另一方面，看看开始就这次的事件建立起类似事情的流程，有监控的流程，相信至少很多误解不会存在。 这个在一到两周内会给到大家结果。 同时，从这次的邮件，我想提几个也许更深层次的问题： 业务部门的发展需要大家的帮助和支持，这次的事件就属于高压力高考核下又找不到解决途径后，憋出来的烂招，结果是大家都受到了连累。我希望能借此事件将看看这边的一些急需的帮助提出来，大家一起探讨。 所谓堵不如梳，有大家一起帮忙，相信类似事件从驱动力上就会小很多。 看到大家很激动的情绪，相信大家都很想为公司好，为用户好，那么大家就一起参与，不如我们从根上去解决问题？ 欢迎大家提出意见和表达意见以及希望看到的结果，但是，还是希望大家不要乱猜测和猜疑，甚至匆忙间就把判定给下了，尤其是一些原则的问题上。 这是一封公开邮件，公开邮件有话语人，就有听众，属于媒体性很强的邮件表达方式。 在业务上推动用的方法不对是一回事，为自己谋私利是另外一件事情。两者最后的落点完全不一样。 希望以后大家在这样类似的邮件里注意这个点，不是说不允许大家说，而是一些很重要的判断，可以先弄明白再表达观点。 最后，想给大家说一说大家所不了解的看看一些情况。 看看的发展其实我想很多人不了解，我也知道看看最近在受到很多公司其他部门的质疑，有发展问题，有团队问题，有管理问题，有道德问题，有产品问题…… 这里作为看看的负责人，我想也就此邮件为看看做一次简短的宣讲。 在优酷土豆既定好赛道的长跑里，我们是跟得最辛苦的一家视频穷公司 我们用最少的花费版权的钱，得到了跟每一家视频公司差不多的内容（除开对方有钱可以做独家，除开MMPA打死不卖给我们的内容） 我们用最少的市场费用现在做到了每天从外部给看看带量750万UV，这个上面我们是市场的第一名 我们用最少的人数在运营着视频门户的红海广告商业模式，一个从技术到产品到内容到市场到销售到编辑到成本控制都要面面俱到的商业模式。 我们用最低的薪资待遇团聚着一帮对迅雷对迅雷看看还有感情的弟兄们，在艰苦奋斗 …………………… 这样的模式下，整个团队发挥出的就是以前继承下来的土匪精神和强烈的生存欲望。 这个相对应的，也造成了很多的不规范和给兄弟部门带来很大的困扰， 这一点，是以后看看要杜绝和规范起来的。请大家相信 尽管跟得困难，但是不意味着我们就一定要傻傻的跟随到底，看看在未来的一两年内，还是一个基础目标，活下去！ 在活着的过程中，不断的寻找机会，给自己补血的同时看能不能找出属于自己的特殊赛道，这个是我最大的职责和责任。请大家相信，我能给大家一个满意的答案。 希望在这个过程里，还是能得到大家的帮助和谅解 最后，尽管大家的邮件里的质疑很尖锐，但是，至少有一点，对迅雷的感情从字里行间我能看到。 我刚生的女儿，在医院里，医生的态度稍微有点不负责的时候，我也是怒火中烧的，所以，对大家的心情我也非常理解。 所以，既然大家都把迅雷当做自己的孩子，真心的爱护和呵护，那我们不妨一起努力，寻找更好的方式来一起解决问题。 一直以来，迅雷看看也是迅雷的一部分. 我说几句： 我们看看业务面临非常大的压力，这点我能理解并感同身受，其实不光是看看，其他产品也有。 在有中国特色的商业伦理和“成功哲学”下，确实有些公司通过一些不规范的手段获得了巨大的商业利益，但是这不意味着我们应该效仿，我们总是有一条底线要坚守。 知错就改是好事，但是不足够，犯了错误就要付出一些代价。 我们没能在公司内部树立一个核心价值观，是我的问题，我自罚30%月薪。另外看看的管理层也一并做出处罚，总的罚金池要match我的。具体请anter了解清楚事情原委后分配。所有罚金由peter暂管，未来进入看看的团队建设费用。 请peter安排HR同事来具体follow up一下。 未完待续……不知道还会有什么样的人出来玩什么手段和说辞，如果有的话，我会持续更新。谢谢关注。 结语 迅雷看看拥有几亿的用户，此事牵扯到的黑色利益链条到底有多少？但此事竟然将在迅雷看看内部不了了之。无人挨罚，无人顶罪，无人遭辞，无人隐退，长此以往，迅雷必亡。","link":"/2013/08/21/迅雷看看事件/"},{"title":"J2EE&SSH 复习","text":"作者：这是大三第一学期学习J2EE三大框架时考试前根据重点做的总结，现在整理到一篇文章里，方便以后查阅，也希望能对初学者提供一些参考。 #SSH之前需要了解的 ##Java基础部分 ###Java 三大平台 Java SE 标准版 主要用于开发一般台式机应用程序 Java ME 微型版 主要用于开发掌上电脑手机等移动设备使用的嵌入式系统 Java EE 企业版 主要用于快速设计、开发、部署和管理企业级的软件系统 ###JSP 和 Servlet &lt;form&gt;标签 action属性：接受表单的服务端程序或动态网页的地址 method属性：表单数据传输到服务器的方法 POST： 在HTTP请求中嵌入表格数据 GET：将表单附加到请求该页的URL地址中 Servlet 和 JSP 的关系： *.jsp文件被传送到服务器后先由服务器翻译成Servlet文件，而Servlet就是*.java文件，然后*.java文件又被翻译成*.class文件再由JVM（Java虚拟机）解释执行。 Servlet 生命周期 开始：装载到容器 初始化：调用init()方法 处理请求：调用service()方法，根据不同的doXXX()方法处理客户端请求，并将结果封装在HttpServletResponse中返回给客户端 移除：调用destroy()方法移除Servlet实例 JSP 内置对象 Request对象 访问客户端请求的信息 Response对象 将服务器端的响应数据发送给客户端 Session对象 服务器单独处理和记录客户端使用者信息的技术 #Struts 2 ##MVC ###MVC 的概念（了解） Model 模型：对操作数据对象的封装 View 视图：处理数据显示的部分 Controller 控制器：负责从视图读取数据，控制用户输入，并向模型发送数据 ###MVC模式的优点 多个视图对应一个模型 模型返回数据和显示逻辑分离 应用被隔离为三层，降低各层间耦合，提供应用可扩展性 控制层包含用户请求权限的概念 更符合软件工程化管理的精神 Struts工作流程 基本流程 浏览器请求一个资源 过滤器Dispatcher查找请求，确定Action 拦截器Filter自动对请求应用通知功能，如验证和文件上传 execute()方法存储数据和（或）重新获得信息 返回结果，可能是HTML、图片、PDF或其他 struts 配置文件 web.xml（位于WebRoot/WEB-INF下） 1234567891011121314151617181920212223242526272829303132333435363738 &lt;filter&gt; &lt;!--配置过滤器--&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!-- 过滤器名 --&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;!--过滤器类的完整包名+类名--&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;!-- 配置过滤器映射范围 --&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt;&lt;!--要配置的过滤器名--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--过滤器映射范围 * 代表所有请求--&gt; &lt;/filter-mapping&gt;``` struts.xml（位于src下）``` &lt;struts&gt; &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;!-- 登录相关 --&gt; &lt;!-- name： action名，class：Action完整包名+类名 --&gt; &lt;action name=&quot;login&quot; class=&quot;com.struts.action.ManagerAction&quot;&gt; &lt;!-- success：请求处理成功 --&gt; &lt;result name=&quot;success&quot;&gt;/main_menu.jsp&lt;/result&gt; &lt;!-- error：请求处理失败 --&gt; &lt;result name=&quot;error&quot;&gt;/login.jsp&lt;/result&gt; &lt;!-- input：验证输入 --&gt; &lt;result name=&quot;input&quot;&gt;/login.jsp&lt;/result&gt; &lt;!-- none：请求完成后不做任何跳转 --&gt; &lt;result name=&quot;none&quot;&gt;&lt;/result&gt; &lt;!-- login：返回登录页面 --&gt; &lt;result name=&quot;login&quot;&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; ##Struts几种校验器 必填字符串校验器 必填校验器 整数校验器 日期校验器 邮件地址校验器 网址校验器 字符串长度校验器 正则表达式校验器 ##Struts的OGNL表达式 #foo.blah // 返回foo.getBlah() ##Struts 标签 &lt;s:if&gt; &lt;s:elseif&gt; &lt;s:else&gt; 类似于Java中if、else if、else的使用 &lt;s:iterator&gt;标签 对对象进行枚举迭代， values指定集合变量 id指定变量名。 status产生一个IteratorStatus变量，包含一下属性方法： int getCount(); 迭代元素个数 int getIndex(); 迭代元素当前索引 boolean getFirst(); 是否为第一个 boolean getEven(); 是否为偶 boolean getLast(); 是否最后一个 bolean getOdd(); 是否为奇 由于iteratorstatus对象并不是ognl的根对象因此访问需要加上 #访问如下例子: 12345&lt;s:iterator value=&quot;{&apos;dd&apos;,&apos;bb&apos;,&apos;cc&apos;}&quot; status=&quot;st&quot;&gt; &lt;s:if test=&quot;#st.odd&quot;&gt; &lt;s:property value=&quot;#st.index&quot;/&gt; &lt;/s:if&gt;&lt;/s:iterator&gt; &lt;s:form&gt;和&lt;s:file&gt;上传标签 类似JSP中的&lt;form&gt;标签（例如上传文件，其中嵌套一个&lt;s:file&gt;标签，并以二进制流的方式处理表单数据，即设置&lt;s:form&gt;的enctype属性为 multipart/form-data） 1234&lt;s:form action=&quot;upload.action&quot; method=&quot;post&quot; entype=&quot;multipart/form-data&quot;&gt; &lt;s:file name=&quot;upload&quot; label=&quot;Upload File&quot;&gt;&lt;/s:file&gt; &lt;s:submit value=&quot;upload&quot; /&gt;&lt;/s:form&gt; ##Struts国际化 在src下新建一个struts.properties文件，并输入以下代码 struts.custom.i18n.resources=资源文件名(例如messageResource) 新建两个资源文件，分别为中文和英文。首先，新建第一个英文资源文件messageResource_en_US.properties `username=usernamepassword=passwordlogin=login 12 再新建一个中文的资源文件`messageResource_zh_CN.properties`(中文值为ASCII码) ``` username=\\u7528\\u6237\\u540d password=\\u5bc6\\u7801 login=\\u767b\\u5f55 ``` 3. 新建jsp页面，在页面中使用国际化文件 ``` &lt;s:textfield name=&quot;user.xh&quot; key=&quot;username&quot; /&gt; &lt;s:password name=&quot;user.pw&quot; key =&quot;password&quot; /&gt; &lt;s:submit value=&quot;%{getText(&apos;login&apos;)}&quot; /&gt; #Hibernate ##概念 ###Hibernate概念 Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了轻量级的封装（未完全封装），使Java程序员可以使用面向对象的编程思想来操纵数据库。 ###ORM概念 ORM（对象/关系映射）是用于将对象与对象之间的关系对应到数据库表与表之间的关系的一种模式。Hibernate作为ORM中间件出现。 ##Hibernate核心接口 Configuration接口 负责管理Hibernate的配置信息 SessionFactory接口 负责创建Session实例 Session接口 Hibernate持久化操作的基础，封装了一些持久化方法例如save、update Transaction接口 Hibernate进行事务操作的接口 Query接口 执行HQL语句进行查询 ##HQL语言 ###定义 HQL是Hibernate Query Language（Hibernate查询语言）。很像SQL语言，操作的对象是类、实例和属性。 ###Hibernate关联映射 一对一关联 多对一单向关联 一对多双向关联 多对多关联 ##Hibernate高级功能 ###Hibernate批量插入 修改Hibernate配置文件 Hibernate.cfg.xml: 1234567891011&lt;hibername-configuration&gt; &lt;session-factory&gt; ... &lt;!-- 设置批量尺寸--&gt; &lt;property name=&quot;hibernate.jdbc.batch_size&quot;&gt;50&lt;/property&gt; &lt;!--配置数据库方言--&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL&lt;/property&gt; &lt;!--关闭二级缓存以提高速度--&gt; &lt;property name=&quot;hibernate.cache_use_second_level_cache&quot;&gt;false&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibername-configuration&gt; Java代码中模拟插入数据: 1234567891011121314151617181920 Session session = HibernateSessionFactory.getSesstion();// 获得Session Transaction ts = session.beginTransaction();// 开始事务 for (int i = 0;i &lt; 500;i++) { Kcb kcb = new Kcb(); // 创建一个新课表 kcb.setKch(i + &quot;&quot;); // 设置课程号（模拟） session.save(kcb); // 存储 if (i % 50 == 0) { session.flush(); // 提交 session.clear(); // 清除缓冲区 } } ts.commit(); // 提交数据 HibernateSessionFactory.closeSession(); // 关闭Session ``` ###Hibernate批量删除1. 修改配置文件，添加查询翻译器属性。2. Java代码中批量删除课程号大于200的课程 Session session = HibernateSessionFactory.getSesstion();// 获得SessionTransaction ts = session.beginTransaction();// 开始事务Query query = session.createQuery(“delete from Kcb where kch&gt;200”);query.executeUpdate();ts.commit(); // 提交数据HibernateSessionFactory.closeSession(); // 关闭Session 123456789101112131415161718192021222324252627282930313233343536373839###实体对象生命周期* 瞬时态 **实体对象在内存中的存在 与数据库无关*** 持久态 **Hibernate所管理的状态*** 脱管状态 **Session实例关闭之后其管理对象的状态**处于持久态的对象也称为PO(Persistence Object)，瞬时对象和脱管对象也称为VO（Value Object）。###Hibernate事务管理* 基于JDBC的事务管理 Hibernate是JDBC的轻量级封装，本身不具备事务管理能力。在事务管理层，Hibernate将其委托给底层的JDBC或JTA，以实现事务管理和调度功能。 * 基于JTA的事务管理 JTA(Java Transaction API)是由Java EE Transction Manager去管理事务。其最大的特点是调用UserTransaction接口的begin、commit和rollback方法来完成事务范围的界定、事务的提交和回滚。JTA可以实现统一事务对应不同的数据库。###Hibernate锁机制* 悲观锁 **对数据被外界修改持保守态度*** 乐观锁 **认为数据很少发生同时存取的问题**##Hibernate与Struts2整合###DAO模式* DAO概念：**Data Access Object，数据访问接口*** DAO组件实现###整合过程1. 建立数据库及表结构2. 在MyEclipse创建对数据库的连接3. 创建Web项目4. 添加Hibernate开发能力5. 生成数据库表对应的Java对象和映射文件6. `hibernate.cfg.xml`中注册映射文件，配置数据库属性 &lt;property name=&quot;connection.username&quot;&gt;[数据库用户名]&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;[数据库密码]&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;[数据库地址、数据库名、访问参数]&lt;/property&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;[数据库驱动]&lt;/property&gt; &lt;!-- 配置数据库方言 --&gt; &lt;property name=”dialect&gt;org.hibernate.dialect.MySQL”&lt;/property&gt; &lt;!-- 注册Hibernate映射表 --&gt; &lt;mapping resource=&quot;com/model/Kcb.hbm.xml&quot;/&gt; ...... 1234567891011121314151617181920212223242526 7. DAO层组件实现8. 添加Struts类库，编写`struts.xml`文件。9. 修改`web.xml`文件。#Spring##Spring概念* Spring是一个开源框架* 为了解决企业应用开发的复杂性而创建的* 使用基本的Java Bean来完成以前只可能由EJB完成的事情* 不仅限于服务端开发* 简单性、可测试性和松耦合##核心机制* Spring的核心机制是依赖注入，也称为控制反转（IoC-DI，Inversion of Control-Dependency Inversion）。* 工厂模式 * 定义 当应用程序中A组件需要B组件协助时，并不直接通过硬编码的方式来创建B组件的实例对象，而是根据需要，通过B对象的工厂类的生产方法来构造B的实例，这样可以降低A与B之间的耦合。 &gt;*（理解）*例如书上179页~181页例子中，为了完成每个国家的人吃饭行走两件事，如果不使用工厂模式，代码实现应该是这样的（为了体现工厂模式的价值，加上Country1~9代表其他国家）： Human humen[] = new Human[11]; Human humen[0] = new Chinese(); Human humen[1] = new American(); Human humen[2] = new Country1(); ...(中间省略7个构造语句) Human humen[10] = new Country9(); for (Human human:humen) { human.eat(); human.walk(); } 12 &gt;而使用工厂模式下，代码是这样： String toCreate[] = new String{&quot;Chinese&quot;, &quot;American&quot;,&quot;Country1&quot;.....,&quot;Country9&quot;}; Factory factory = new Factory(); for (String countryName:toCreate) { Human human = factory.getHuman(countryName); human.eat(); human.walk(); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 &gt;两段代码的作用是一样的，第一个例子加上中间省略的语句，实际上有效代码有16行，而第二个例子只有7行。两段代码最大的差别在于对象的构造部分，在使用中不需要逐个使用其构造器来构造对象，而是选择使用工厂来完成，从而降低了吃饭行走组件和具体每个国家的人的耦合性。 * Spring的依赖注入 * 特点： 开发人员不用创建工厂，可以直接应用Spring提供的依赖注入方式。 * 两种注入方式： * 设置注入 通过setter方法注入被调用者的实例。 1. 为属性设置setter方法 2. 在配置文件中指定需要容器注入的属性 &lt;bean id=&quot;english&quot; class=&quot;org.English&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;chinese&quot; class=&quot;org.Chinese&quot;&gt; &lt;property name=&quot;lan&quot; ref=&quot;english&quot;&gt;&lt;/property&gt; &lt;/bean&gt; * 构造注入 1. 为Bean类添加一个构造注入所需要的带参数的构造方法 2. 在配置文件里为bean设置构造注入（constructor-arg属性） &lt;bean id=&quot;english&quot; class=&quot;org.English&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;chinese&quot; class=&quot;org.Chinese&quot;&gt; &lt;constructor-arg ref=&quot;english&quot;&gt;&lt;/constructor-arg &gt; &lt;/bean&gt; ##Spring核心接口及基本配置* 核心接口 1. BeanFactory 创建和分发bean的通用工厂 2. ApplicationContext（应用上下文） * 对国际化的支持 * 提供载入资源的通用方法，如文本和图片 * 可以向注册为监听器的Bean发送事件* bean的基本配置 * 配置格式 格式： &lt;bean id=&quot;[bean的id]&quot; class=&quot;[bean完整类名]&quot; /&gt; 例如： &lt;bean id=&quot;foo&quot; class=&quot;com.spring.Foo&quot; /&gt; ##Spring 与 Struts 整合步骤1. 创建项目2. 添加Struts相关Jar包3. 创建页面及其Action4. 添加Spring框架支持包：`struts2-spring-plugin.jar`5. 修改web.xml使程序增加对Spring的支持 * 添加Spring的listener * 在context-param中配置ApplicationContext的路径 6. *创建消息包文件 `struts.properties`* 内容为： struts.objectFactory=spring##Spring 与 Hibernate 整合步骤1. 建立数据库2. 创建Web项目3. 添加Spring开发能力 * Spring 2.0 Core Libraries * Spring Web Libraries * Spring 2.0 AOP Libraries * Spring 2.0 Persistence JDBC Libraries 4. 加载Hibernate框架5. 生成与数据库表对应的Java数据对象和映射6. 编写DAO接口和实现类7. 修改Spring配置文件 * 数据库相关配置 * Hibernate的SessionFactory配置 * 注入DAO 8. Spring的Bean很好地管理了以前在hibernate.cfg.xml文件中创建SessionFactory，使文件更容易阅读9. 编写测试类##SSH 三种框架的整合* SSH的层次划分 1. Hibernate完成数据的持久层应用 2. Spring来管理组件 3. Struts完成页面跳转 * SSH中DAO的具体实现 * find 查找学生方法 * findAll 分页查找方法 * save 插入方法 * update 更新方法 public class XsDaoImpl extends HibernateDaoSuppport implements XsDao{ // 删除学生信息 public void delete(String xh){ getHibernateTemplate().delete(find(xh)); } // 查找学生信息 public Xsb find(String xh){ return getHibernateTemplate().find(&quot;from Xsb where xh=?&quot;, xh); } // 查找所有学生信息 public List&lt;Xsb&gt; findAll() { return getHibernateTemplate().find(&quot;from Xsb&quot;);; } // 添加学生信息 public void save(Xch xch){ return getHibernateTemplate().save(xch); } // 修改学生信息 public void update(Xch xch){ getHibernateTemplate().update(xch); } } 123456789101112131415161718192021222324252627282930313233343536373839 #Ajax##概述Ajax不是一种全新的技术，它是几种技术的融合：* *HTML/XHTML* 实现页面内容的表示* *CSS* 格式化文本内容* *DOM* 对页面内容进行动态更新* *XML* 实现数据交换和格式转换* *XMLHttpRequest* 实现与服务器异步通信* *JavaScript* 实现以上技术的融合特点：* 必须是客户端和服务器一同合作的应用程序* JavaScript是撰写Ajax应用程序的客户端语言* XML是请求或回应时建议使用的交换信息的格式##JavaScript浏览器对象* `window`对象 window对象描述*浏览器窗口*的特征。它可以认为是任何对象的假定父对象 * `Document`对象 Document表示浏览器窗口或者其中一个框架中显示的*HTML文档*。 * `History`对象 history对象包含用户已经*浏览过的URL集合*。 ##XMLHttpRequest对象* XMLHttpRequest概述和特点 XMLHttpRequest对象提供客户端与HTTP服务器异步通信的协议。通过它Ajax可以像桌面应用一样只同服务器进行数据层交换，而不必每次都刷新页面。（减轻服务器负担，加快响应速度）* 获得XMLHttpRequest的方法 var xmlHttp; function createXMLHttpRequest() { if (window.XMLHttpRequest) { // Firefox、Safari、Chrome下获取XMLHttpRequest对象的方法 xmlHttp = new XMLHttpRequest(); } else { // IE下获得XMLHttpRequest的方法 xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } }` ##DWR ###概述和特点 DWR是类似于Hibernate的开源框架。借助DWR开发人员无需具备专业的JavaScript知识就可以轻松实现Ajax，使Ajax应用更加“平民化”。 ###使用方法 导入 DWR 的Jar包 在web.xml中添加DWR的servlet映射 添加dwr.xml文件来配置那些Java类可以被DWR应用创建并远程调用。","link":"/2014/12/26/J2EE-Test-Note/"},{"title":"怎样充分借助互联网自学？","text":"作者：程浩 原文地址） 写在前面 有很多朋友写私信和E-mail问我：“我应该怎么读书？读不进去怎么办？读了记不住怎么办？记住了用不上又怎么办？”关于类似的问题，我每天可以收到十几封信件。但是碍于时间和精力有限，我真的很难每封信都单独回复。所以借着这个问题，我将一次性回复给所有人。不敬之处，还请见谅。我会把自己所有关于读书和学习的方法，系统地梳理出来，然后一字不落地分享给大家。这些方法不是我原创的，而是通过各种渠道获得，然后经过实践，再根据自身情况作出的整合与修改，最后成型。我不能保证适合每一个人，甚至不能保证其方法的合理性。我唯一能够保证的就是——有效。 最后，这个方法只适合那些对学习和阅读有强烈欲望，并且有一定自控能力的人。如果你是一个必须依靠别人督促才能主动去学习的人，完全可以跳过本文不看。 正文 首先，一个人自学，很难。这个难，不是难在学习途径和学习工具，而是难在没有考试，没有人来检验你的成绩。考试虽然是一个万恶的东西，但是任何事物都存在两面性。考试的优点就在于，它能够告诉你此刻应该学什么。为什么有的人一晚上就可以背下整本书？因为有考试。只要有考试，就一定有重点；没有考试，也就没有重点；因为没有重点，所以全是重点。这就是为什么经常有人问“我想学习XX学，请问有什么建议”、“自学XX学，应该怎么开始”之类问题的原因。他们寻求的所谓建议，实际上就是希望有过相同学习经历的人，能够给他们画出一个重点，否则就不知道应该如何开始。 其次，自学是一个非常枯燥而且漫长的过程。你花三个月去钻研一个领域，不会觉得自己有什么提高。但是你花三个月去钻研一个领域，肯定会遇到自己难以突破的瓶颈。许多人走到这个程度就放弃了，因为他们会开始怀疑自己，动摇自己——这是我真正的兴趣吗？我的天赋是不是不在这儿？不然为什么我学得这么困难？要不然尝试一下别的领域？说不定会有新发现——于是，他们从一个领域跳到另一个领域，然后再次重复以上过程…… 学习遇到瓶颈，其实是一件再正常不过的事情。就像一个奔跑的人，迟早会撞到阻挡自己前进的墙壁。如果遇到墙壁就转弯，遇到墙壁就转弯，那你跑一辈子也跑不出这间房子。所以，无论你面向何处，你要做的就是想尽一切办法，翻越自己面前这堵墙，千万不要转弯。墙内和墙外就是两个世界，业余和专业就是一墙之隔。 所以，自学的第一步就是要解决这些问题。具体的解决方法，基本可以概括为以下四点： 一、制定计划，设立目标 计划是长期的，目标是短期的。无论学习什么，你都要先制定一个长远的计划。计划之下，再由多个短期目标组成。也许你的计划制定了三年，但是却只执行了六个月，可是如果你不制定计划，那你也许就只能坚持三天。一个人如果没有具体目标，其实很容易受到内外因素的双重干扰而放弃。绝大多数人的半途而废，起因都是自身的迷茫与浮躁。因为他们空有热情与想法，但是缺少计划与蓝图（具体参考我的另一个回答《人一般为什么浮躁？》）。 【长期计划】 以一个三年的学习计划为例。你希望自己三年后在该领域能达到一个什么样的水平？你这三年内要阅读该领域的哪些书籍？你这三年内要掌握（指不必查阅）该领域的哪些知识？你在三年后将把这些知识用在何处？有没有衡量自己学习质量的标准？诸如此类。 要把计划列成一个详细的清单，而且要注明时间和完成期限。如果有两个人一起学习，相互监督就最好了。 三年后，这个学习计划到底能不能完成，其实并不重要。它只是一个方向，告诉你，此时此刻你还有多少事情没做，让你一刻也别闲着。而这个学习计划的核心，也就是它的关键之处，在于你全力以赴地执行了多少？是不是真的学了？是不是真的懂了？是不是真的会了？如果是，那这三年的时光，你赚了！ 【短期目标】 1、细化制 把一个三年的学习计划，按照某种规律（逻辑、类型、阶段等等）分成三份，安排到每一年，然后再把每年的学习内容细化，安排到每一个月。因为一个月有三十天，所以可以把一个月分为三个周期：第一个十天，第二个十天，第三个十天，十天就是一个周期。确定这个周期学习什么，下个周期学习什么，以此类推。 最后再画一张每日工作表，自己每天晚上计划一下第二天的学习内容。看自己每天能用多少时间来学习？如果是两个小时，那么这些时间能够学习多少内容？比如读几页书？写几千字？整理几张笔记？收集哪些资料？这需要视个人情况和能力而定。千万不要一开始就做太繁重的任务，当然也不能太轻松。太繁重的任务，容易出现抵触心理。太轻松的任务，又很难出现效果。所以，最好是那种踮着脚尖才能够到的程度。 2、奖惩制 短期目标的核心价值，在于清晰明确的奖惩机制。而所谓的奖励和惩罚，实际上就是一种自我限制。 我相信，每个人在一天当中，都会出现某些频率很高的生活习惯。比如，聊QQ，打手机，看美剧，刷微博，上知乎。这些生活习惯，如果不做就会带来一点麻烦或者不适，但又不会造成很严重的影响，最适合用来当作奖励或者惩罚。 具体方法是，先规定自己每天刷微博或者上知乎的时间总量，比如是五个小时。然后计划自己每天至少阅读二十页书，一旦无法完成，则以一页等于三十分钟的算法，减去当日或次日刷微博、上知乎的时间。或者给自己增加一个每天运动的项目，比如每天慢跑三十分钟，少读一页则增加十分钟。如果超额完成当天的任务，就可以减去一定的运动时间，或者增加自己的娱乐时间。 奖惩制的关键，在于你有没有强大的执行力，以及自我约束的能力。 可能有的人会说：“我在学校听老师的，在公司听领导的，在老家听父母的，在自己家听老婆的。好不容易有点空闲时间，学点自己喜欢的，为什么又把自己画进如此累人的条条框框里？” 没错。细化制和奖惩制的建立，的确会给我们的生活带来很多约束，甚至会产生一种潜在的压力。但是这种轻度的压力，正是一个人自学所需要的。兴趣和决心只能带来一时的学习热情，习惯和计划才是自学的主要形式。我们的懒惰心理与拖延心理，远比自己想象的要强大。就像此刻，可能有一千个人看到我的这篇文章，但是保存起来准备实践的可能不到一百人，而这一百人真正能落实到行动上的，顶多几人而已。绝大多数就是存起来，从此遗忘在电脑硬盘里。 二、记录分析，定期调整 【记录】 任何学习计划都不是完美的。尤其是刚刚开始学习的人，对新的学习领域不了解，往往低估眼前的学习内容，却高估自己的学习能力。所以，需要建立一个学习记录表，每天记录和观察自学过程中的一切变化。比如，你一天读二十页书，连续三天轻松完成。那是不是就能证明，你实际上还学有余力？是不是可以从二十页增加到二十五页？再比如，你一开始每天学习两小时，后来发现可以增加每天的碎片时间进行学习，那么同样是碎片时间，在公交车上读书和排队等候时读书，同样的时间内，哪一个环境下的学习质量更高？ 记录的重点，一定要放在时间和内容上，目的就是观察自己在相同的时间下，如何能够学习更多的内容，并且更好的理解。 学习记录表可以自己绘制，也可以用《番茄工作法》的记录表为基础，作几个数据上的改良。具体情况根据自己的需求而定吧。 【分析】 学习计划进行到一定程度的时候，我们就会面临两个问题：要么学习效果明显提高；要么学习效果差强人意。 这时候，我们就要通过之前的记录表进行分析。如果学习效果有所提高，那么是哪方面的学习内容带来的提高？如果学习效果并不理想，那么说明这个学习计划的内容有所问题。你要做的就是从记录表上找出问题的症结所在。如果你不能从每天学习的内容和时间上发现问题，说明你对自己的知识储备和对该领域的认识还不够深入，而且缺乏基本的问题分析能力，那么我就可以认为你没有达到一个人自学的最低门槛——发现问题、分析问题、修正问题。 总之，这一阶段就是要做一些“取其精华，弃其糟粕”的工作，让时间的价值最大化。 随着学习程度的深入，自身的水平也会有所变化，兴趣和方向也会逐渐清晰。要根据自身的情况，对计划作出适当的调整。 三、收获总结，定向输出 【总结】 读过一本书，一定要写读书笔记。要利用所有学到的知识，写出一篇总结式的文章，而不仅仅是停留在画线批改、寻章摘句的刻板方式上。笔记一定要按照自己的思维模式去写，千万不要套用别人的笔记格式，那完全是本末倒置。 笔记的价值并不在于内容，你就算记得内容清晰、数据翔实，复习起来也不会比翻一遍原文来得更快。如果仅仅是记知识点的话，在书上画线就够了。写笔记，目的是把书中的知识和个人的理解，两者融会贯通，最终形成自己的想法和思路。笔记写成什么样子并不重要，重要的是思考如何写笔记的过程。这同样是碎片知识内化为整体知识的过程。 将写好的笔记标注时间，然后存档。未来复习一本书时，随时往上面增加新的内容。 【输出】 把你这一阶段学到的东西拿出来展示给大家，一定要找到适合的平台。可以在知乎写回答，也可以建立一个自己的博客，也可以去一些比较有特色的论坛写写文章，和有相同爱好的人打打笔仗。 写作就是一个思维整理与归纳的过秤，尤其是当你试图说服别人的时候，这一点就会变得尤为明显。你在写作的过程中，需要不断回忆自己学到的知识，并且利用自己的语言将它表达出来。你还要思考文章的结构，怎么才能循序渐进地把一个复杂的道理讲得明白，讲得令人心服口服，讲得让人无懈可击。如果有某些细节自己不知道、不清楚，为了避免文中出现疏漏，你就会去查阅资料或者翻阅书籍，这就完成了一个巩固与复习的过程。更重要的是，你还会发现自己有哪些短板，还需要学习哪方面的知识。这些都是一个人自学时，在孤立状态下难以发现的。 我读《与众不同的心理学》时发现，科学的进步来源于质疑和修正。那知识的进步来源于什么呢？我认为应该是碰撞和需求。人们利用自身所学的知识，与他人进行思想和观点上的交锋，不仅可以发现自己的不足，还会产生新思想的火花。所以，将知识输出的过程，就是与他人进行思想交锋的过程。 我读书最多，效果最好的时候，是自己16岁时，跟六位同样热爱日本文学的网友，一起建立了一个“竹林（取竹林七贤之意，羞愧得很）读书会”。我们约定每周阅读同一本书。到了星期天，七个人每人写一篇书评，在群里轮流谈感想。因为害怕自己说得不好，所以每次看书都恨不得把一本书生吞活剥，把书里的内容嚼得血肉横飞，目的就是为了能在其他人面前说出点儿别人没发现的东西。虽然那时候像个傻帽，看书看得十分做作。但如今我所读过的日本文学里，有百分之八十都是当初硬着头皮读下的，而且每一本书的印象都非常深刻。 四、自我经营，时间盈利 我不得不说几句很残忍的话：其实在任何一个学科领域，自学的人，都很难超越科班出身的人。也许会有，但是少之又少。 那是不是说明自学就没有价值呢？ 当然不是！自学的价值极其巨大，甚至可以说，人与人最大的差别，不是他们的社会地位和收入水平，而是他们在业余时间学什么、做什么。所以人们常说，你的人生取决于晚饭后的两小时。但是这个价值，并不一定是安身立命的本事，而是一种潜移默化的影响，一种缓慢而彻底的蜕变。有时候，自学带来的价值，往往难以通过正面表现出来，但是却真真切切地影响了一个人的言行举止，生活习惯。而言行举止和生活习惯很大程度上就是决定一个人性格与命运的重要因素。 所以，我认为自学的本质就是管理自己，经营自己，掌控自己，驾驭自己，最后得到时间上的盈利——时间价值最大化。 什么叫“经营自己”？ 我曾经举过一个例子：假如你的名字就是知乎的一个专栏，发稿频率是一周一篇，关注者就是专栏的发行量，赞同数和感谢数就是读者的反响，评论就是读者的来信，那么作为专栏的作者，你该如何维护这个专栏的品牌？又该如何保证写出高质量的内容？在大局已定（各领域的大牛）的知乎江湖，默默无闻的你如何才能闯出一片天地？你读了那么多书，此刻它们能帮你解决几个问题？如果一个都解决不了，它们能否成为你创作的素材？在实践的过程当中，你发现自己的短板是什么？ “经营自己”就是别把自己当作一个有主观意识的人，而是看作一个工具。主观意识往往会带来许多干扰。在主观意识之下，你考虑更多的是“我想做什么”，如果是一个工具，你考虑更多的则是“我该做什么”。如果一个人不能管理自己，又如何管理别人？如果一个人不能赚取时间，又如何赚取财富？ 说到底，人，终究是要学会使用自己，而不是放纵自己。 后记 我再说两件事儿： 一、我从来不认为自学的困难是无人指导，更不是没有学习的途径。如今，我们处在一个信息爆炸的时代，我们获取知识的成本空前的低，只要有足够的好奇心，我们可以通过无数种方式来了解自己想要了解的一切东西。任何困难都是一面等待我们翻越的围墙。唯一的问题在于，我们是否有开辟未知领域的决心和毅力。 二、无论学什么，一定要当机立断，今天写计划，今天就执行，别等别拖别准备。如果向人请教，不要问类似“XXX应该怎么学”这样大而无当的问题。问题一定要具体到某一个细节。你可以问“秦国统一六国具备哪些基本优势（虽然这还是一个大问题）”，但是你千万不要问“秦汉史应该怎么学”。不是说这个问题有多么深奥，而是因为它太过基础，太过宽泛，反倒没有一个答案。再举一个例子，你如果问“计算机应该怎么学”？我保证你得不到想要的答案，因为太过宽泛了，你只能问“如何使用Photoshop的蒙板和滤罩”？问题越小，得到的答案含金量越高。 嗯哼，开始学习吧！ 打个广告： 豆瓣个人主页：伯爵在城堡新浪微博：http://weibo.com/now2012","link":"/2013/08/22/怎样充分借助互联网自学/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"tips","slug":"tips","link":"/tags/tips/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"MIUI","slug":"MIUI","link":"/tags/MIUI/"},{"name":"Oracle","slug":"Oracle","link":"/tags/Oracle/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Mavericks","slug":"Mavericks","link":"/tags/Mavericks/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"iTunes","slug":"iTunes","link":"/tags/iTunes/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"RxAndroid","slug":"RxAndroid","link":"/tags/RxAndroid/"},{"name":"Dagger 2","slug":"Dagger-2","link":"/tags/Dagger-2/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Repost","slug":"Repost","link":"/tags/Repost/"},{"name":"CI","slug":"CI","link":"/tags/CI/"},{"name":"GitLab","slug":"GitLab","link":"/tags/GitLab/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/博客搭建/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"利器","slug":"利器","link":"/tags/利器/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"课堂笔记","slug":"课堂笔记","link":"/tags/课堂笔记/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"评测","slug":"评测","link":"/tags/评测/"},{"name":"Octopress","slug":"Octopress","link":"/tags/Octopress/"},{"name":"编程随想","slug":"编程随想","link":"/tags/编程随想/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"知乎","slug":"知乎","link":"/tags/知乎/"},{"name":"生活技能","slug":"生活技能","link":"/tags/生活技能/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"软件测试","slug":"软件测试","link":"/tags/软件测试/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/嵌入式/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"复习","slug":"复习","link":"/tags/复习/"},{"name":"编译原理","slug":"编译原理","link":"/tags/编译原理/"},{"name":"软件工程","slug":"软件工程","link":"/tags/软件工程/"},{"name":"业界新闻","slug":"业界新闻","link":"/tags/业界新闻/"},{"name":"Java EE","slug":"Java-EE","link":"/tags/Java-EE/"},{"name":"SSH框架","slug":"SSH框架","link":"/tags/SSH框架/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"自学","slug":"自学","link":"/tags/自学/"}],"categories":[]}